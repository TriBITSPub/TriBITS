.. WARNING: The file UtilsMacroFunctionDoc.rst is autogenerated from
.. the file UtilsMacroFunctionDocTemplate.rst in the script
.. generate-dev-guide.sh.  Only the file UtilsMacroFunctionDoc.rst
.. should be directly modified!

ADD_SUBDIRECTORIES()
++++++++++++++++++++

Macro that adds a list of subdirectories all at once (removed boiler-place
code).

Usage::

  ADD_SUBDIRECTORIES(<dir1> <dir2> ...)

ADVANCED_OPTION()
+++++++++++++++++

Macro that sets an option and marks it as advanced (removes boiler-plate and
duplication).

Usage::

  ADVANCED_OPTION(<varName> [other arguments])

This is identical to::

  ADVANCED_OPTION(<varName> [other arguments])
  MARK_AS_ADVANCED(<varName>)

ADVANCED_SET()
++++++++++++++

Macro that sets a variable and marks it as advanced (removes boiler-plate
and duplication).

Usage::

  ADVANCED_SET(<varName> [other arguments])

This is identical to::

  ADVANCED_SET(<varName> [other arguments])
  MARK_AS_ADVANCED(<varName>)

APPEND_CMNDLINE_ARGS()
++++++++++++++++++++++

Utility function that appends command-line arguments to a variable of
command-line options.

Usage::

  APPEND_CMNDLINE_ARGS(<var> "<extraArgs>")

This function just appends the command-line arguments in the string
``"<extraArgs>"`` but does not add an extra space if ``<var>`` is empty on
input.

APPEND_GLOB()
+++++++++++++

Utility macro that does a ``FILE(GLOB ...)`` and appends to an existing list
(removes boiler-plate code).

Usage::

  APPEND_GLOB(<fileListVar> <glob0> <glob1> ...)

On output, ``<fileListVar>`` will have the list of glob files appended.

APPEND_GLOBAL_SET()
+++++++++++++++++++

Utility macro that appends arguments to a global variable (reduces
boiler-plate code and mistakes).

Usage::

  APPEND_GLOBAL_SET(<varName> <arg0> <arg1> ...)

NOTE: The variable ``<varName>`` must exist before calling this function.
To set it empty initially use `GLOBAL_NULL_SET()`_.

APPEND_SET()
++++++++++++

Utility function to append elements to a varible (reduces boiler-plate
code).

Usage::

  APPEND_SET(<varName> <arg0> <arg1> ...)

Just calls::

  LIST(APPEND <varName> <arg0> <arg1> ...)

APPEND_STRING_VAR()
+++++++++++++++++++

Append strings to an existing string variable (reduces boiler-place code and
reduces mistakes).

Usage::

  APPEND_STIRNG_VAR(<stringVar> "<string1>" "<string2>" ...)

Note that the usage of the characters ``'['``, ``']'``, ``'{'``, ``'}'`` are
taken by CMake to bypass the meaning of ';' to separate string characters.

If you want to ignore the meaning of these special characters and are okay with
just adding one string at a time use `APPEND_STRING_VAR_EXT()`_.

APPEND_STRING_VAR_EXT()
+++++++++++++++++++++++

Append a single string to an existing string variable, ignoring ';' (reduces
boiler-place code and reduces mistakes).

Usage::

  APPEND_STIRNG_VAR_EXT(<stringVar> "<string>")

Simply sets ``<stringVar> = "${<stringVar>}<string>"``.

APPEND_STRING_VAR_WITH_SEP()
++++++++++++++++++++++++++++

Append strings to a given string varible, joining them using a seperator.

Usage::

  APPEND_STRING_VAR_WITH_SEP(<stringVar> "<sepStr>" "<str0>" "<str>" ...)

Each of the strings ``<stri>`` are appended to ``<stringVar>`` using the
separation string ``<sepStr>``.

ASSERT_DEFINED()
++++++++++++++++

Assert that a varaible is defined and if not call ``MESSAGE(SEND_ERROR ...)``.

Usage::

  ASSERT_DEFINED(<varName>)

This is used to get around the problem of CMake not asserting the
defreferencing of undefined varibles.  For example, how do you know if you
did not mispell the name of a varible in an if statement like::

  IF (SOME_VARBLE)
    ...
  ENDIF()

?  If you mispelled the varible ``SOME_VARBLE`` (which you likely did in
 this case), the the if statement will always be false.  To avoid this
 problem when you always expect the explicitly set, instead do::

  ASSERT_DEFINED(SOME_VARBLE)
  IF (SOME_VARBLE)
    ...
  ENDIF()

Now if you misspell the varible, it will asset and stop processing.  This is
not a perfect solution since you can mispell the varible name in the
following if statemnt but typically you would always just copy and paste
between the two statements so they are always the same.  This is the best we
can do in CMake unfortunately.

COMBINED_OPTION()
+++++++++++++++++

Set up a bool cache variable (i.e. an option) based on a set of dependent
options.

Usage::

  COMBINED_OPTION( <combinedOptionName>
    DEP_OPTIONS_NAMES <depOpName0> <depOptName1> ...
    DOCSTR "<docstr0>" "<docstr1" ...
    )

This sets up a bool cache variable ``<combinedOptionName>`` which is
defaulted to ``ON`` if all of the listed dependent option varaibles
``<depOpName0>``, ``<depOptName1>``, ... are all ``ON``.  However, if
``<combinedOptionName>`` is set to ``ON`` by the user and not all of the
dependent option varibles are also true, this results in a fatal eror and
alll processing stops.

This is used by a CMake project to by default automatically turn on a
feature that requires a set of other features to also be turned on but
allows a user to disable the feature if desired.

CONCAT_STRINGS()
++++++++++++++++

Concatenate a set of string argumnets.

Usage::

  CONCAT_STRINGS(<outputVar> "<str0>" "<str1>" ...)

On output, ``<outputVar>`` is set to ``"<str0><str1>..."``.

DUAL_SCOPE_APPEND_CMNDLINE_ARGS()
+++++++++++++++++++++++++++++++++

Utility function that appends command-line arguments to a variable of
command-line options and sets the result in current scope and parent scope.

Usage::

  DUAL_SCOPE_APPEND_CMNDLINE_ARGS(<var> "<extraArgs>")

Just calls `APPEND_CMNDLINE_ARGS()`_ and then ``SET(<var> ${<var>} PARENT_SCOPE)``.

DUAL_SCOPE_PREPEND_CMNDLINE_ARGS()
++++++++++++++++++++++++++++++++++

Utility function that prepends command-line arguments to a variable of
command-line options and sets the result in current scope and parent scope.

Usage::

  DUAL_SCOPE_PREPEND_CMNDLINE_ARGS(<var> "<extraArgs>")

Just calls `PREPEND_CMNDLINE_ARGS()`_ and then ``SET(<var> ${<var>} PARENT_SCOPE)``.

DUAL_SCOPE_SET()
++++++++++++++++

Macro that sets a variable name both in the current scope and the
parent scope.

Usage::

   DUAL_SCOPE_SET(<varName> [other args])

It turns out that when you call ``ADD_SUBDIRECTORY(<someDir>)`` or enter a
FUNCTION that CMake actaully creates a copy of all of the regular non-cache
varaibles in the current scope in order to create a new set of variables for
the ``CMakeLists.txt`` file in ``<someDir>``.  This means that if you call
``SET(SOMEVAR Blah PARENT_SCOPE)`` that it will not affect the value of
``SOMEVAR`` in the current scope.  This macro therefore is designed to set
the value of the variable in the current scope and the parent scope in one
shot to avoid confusion.

Global variables are different.  When you move to a subordinate
``CMakeLists.txt`` file or enter a function, a local copy of the variable is
*not* created.  If you set the value name locally, it will shadow the global
variable.  However, if you set the globlal value with SET(SOMEVAR someValue
CACHE INTERNAL ""), then the value will get changed in the current
subordinate scope and in all parent scopes all in one shot!

GLOBAL_NULL_SET()
+++++++++++++++++

Set a variable as a null internal global (cache) variable (removes boiler
plate).

Usage::

  GLOBAL_NULL_SET(<varName>)

This just calls::

  SET(<varName> "" CACHE INTERNAL "")

GLOBAL_SET()
++++++++++++

Set a variable as an internal global (cache) variable (removes boiler
plate).

Usage::

  GLOBAL_SET(<varName> [other args])

This just calls::

  SET(<varName> [other args] CACHE INTERNAL "")

JOIN()
++++++

Join a set of strings into a single string using a join string.

Usage::

  JOIN(<outputStrVar> <sepStr> <quoteElements> 
    "<string0>" "<string1"> ...)

Arguments:

  ``<outputStrVar>``

    The name of a variable that will hold the output string.

  ``<sepStr>``

    A string to use to join the list of strings.

  ``<quoteElements>``

    If TRUE, then each ``<stingi>`` is quoted using an escaped quote char
     ``\"``.  If ``FALSE`` then no escaped quote is used.

On output the variable ``<outputStrVar>`` is set to::

  "<string0><sepStr><string1><sepStr>..."

If ``<quoteElements>=TRUE``, then it is set to::

  "\"<string0>\"<sepStr>\"<string1>\"<sepStr>..."

For example, the latter can be used to set up a set of command-line
arguments given a CMake array like::

  JOIN(CMND_LINE_ARGS " " TRUE ${CMND_LINE_ARRAY})

WARNING: Be careful to quote string arguments that have spaces because CMake
interpet those ase array boundaries.

MESSAGE_WRAPPER()
+++++++++++++++++

Function that wraps the standard CMake/CTest ``MESSAGE()`` function call in
order to allow unit testing to intercept the call.

Usage::

  MESSAGE_WRAPPER(<arg0> <arg1> ...)

This function takes exactly the same argumnets as built-in ``MESSAGE()``.
When the varible ``MESSAGE_WRAPPER_UNIT_TEST_MODE`` is set to ``TRUE``, then
this function will not call ``MESSAGE(<arg0> <arg1> ...)`` but instead will
prepend set to global varible ``MESSAGE_WRAPPER_INPUT`` that input
argumnets.  To capture just this call's input, first call
``GLOBAL_NULL_SET(MESSAGE_WRAPPER_INPUT(MESSAGE_WRAPPER_INPUT)`` before
calling this function.

This function allows one to unit test other user-defined CMake macros and
functions that call this to catch error conditions wihtout stopping the
CMake program.  Otherwise, this is used to capture print messages to verify
that they say the right thing.

MULTILINE_SET()
+++++++++++++++

Function to set a single string by concatenating a list of separate strings

Usage::

  MULTILINE_SET(<outputStrVar>
    "<string0>"
    "<string1>"
    ...
    )

On output, the local variables ``<outputStrVar>`` is set to::

  "<string0><string1>..."

The purpose of this is to make it easier to set longer strings without going
to far to the right.

PARSE_ARGUMENTS()
+++++++++++++++++

Parse a set of macro/functon input arguments into different lists.  This
allows the easy implementation of keyword-based user-defined macros and
functions.

Usage::

  PARSE_ARGUMENTS(
    <prefix>  <argNamesList>  <optionNamesList>
    <inputArgsList>
    )

Arguments to this macro:

  ``<prefix>``

    Prefix ``<prefix>_`` added the list and option variables created listed
    in ``<argNamesList>`` and ``<optionNamesList>``.

  ``<argNamesList>``

    Quoted array of list arguments (e.g. ``"<argName0>;<argName1>;..."``).
    For each varaible name ``<argNamei>``, a local varible will be created
    in the current scope with the name ``<prefix>_<argNamei>`` which gives
    the list of varibles parsed out of ``<inputArgsList>``.

  ``<optionNamesList>``

    Quoted array of list arguments (e.g. ``"<optName0>;<optName1>;..."``).
    For each varaible name ``<optNamei>``, a local varible will be created
    in the current scope with the name ``<prefix>_<optNamei>`` that is
    either set to ``TRUE`` or ``FALSE`` depending if ``<optNamei>`` apears
    in ``<inputArgsList>`` or not.

  ``<inputArgsList>``

    List of arguments keyword-based arguments passed in for the outer macro
    or function to be parsed out into the different argument and option
    lists.

What this macro does is very simple yet very useful.  What it does is to
allow you to create your own user-defined keyword-based macros and functions
like is used by some built-in CMake comamnds..

For example, consider the following user-defined macro that uses both
positional and keyword-based arguments using ``PARSE_ARGUMENTS()``::

  MACRO(PARSE_SPECIAL_VARS  BASE_NAME)

    PARSE_ARGUMENTS(
      #prefix
      ${BASE_NAME}
      #lists
      "ARG0;ARG1;ARG2"
      #options
      "OPT0;OPT1"
      ${ARGN}
      )

  ENDMACRO()

Calling this macro as::

  PARSE_SPECIAL_VARS(MyVar ARG0 a b ARG2 c OPT1)

sets the following varibles in the current scope::

  MyVar_ARG0="a;b"
  MyVar_ARG1=""
  MyVar_ARG2="c"
  MyVar_OPT0="FALSE"
  MyVar_OPT1="TRUE"

This allows you to define user-defined macros and functions that have a
mixture of positional arguments and keyword-based arguments like you can do
in other languages.  The keyword-based arguments can be passed in any
order and those that are missing are empty (or false) by default.

Any initial arguments that are not recongnised as ``<argNamesList>`` or
``<optionNamesList>`` keyword arguments will be put into the local varible
``_DEFAULT_ARGS``.  If no arguments in ``${ARGN}`` match any in
``<argNamesList>``, then all non-option arguments are point into
``DEFAULT_ARGS``.  For example, if you pass in::

  PARSE_SPECIAL_VARS(MyVar ARG5 a b c)

you will get::

  DEFAULT_ARGS="a;b;c"
  MyVar_ARG0=""
  MyVar_ARG1=""
  MyVar_ARG2=""
  MyVar_OPT0="FALSE"
  MyVar_OPT1="FALSE"

Multiple occurances of keyword arguments in ``${ARGN}`` is allowed but only
the last one listed will be recored.  For example, if you call::

  PARSE_SPECIAL_VARS(MyVar ARG1 a b ARG1 c)

then this wil set::

  MyVar_ARG0=""
  MyVar_ARG1="c"
  MyVar_ARG2=""
  MyVar_OPT0="FALSE"
  MyVar_OPT1="FALSE"

This is actually consistent with the way that most arugment list parsers
behave with respect to multiple instances of the same argument so hopefully
this will not be a surprise to anyone.

If you put an option keyword in the middle of a keyword argument list, the
option keyword will get pulled out of the list.  For exmaple, if you call::

  PARSE_SPECIAL_VARS(MyVar ARG0 a OPT0 c)

then this wil set::

  MyVar_ARG0="a;c"
  MyVar_ARG1=""
  MyVar_ARG2=""
  MyVar_OPT0="TRUE"
  MyVar_OPT1="FALSE"

If ``PARSE_ARGUMENTS_DUMP_OUTPUT_ENABLED``is set to ``TRUE``, then a bunch
of detailed debug info will be printed.  This should only lbe used in the
most desparate of debug situations because it will print a *lot* of output!

**PERFORMANCE:** This function will scale as::

  O( (len(<argNamesList>) * len(<optionNamesList>)) * len(<inputArgsList>) )

Therefore, this could scale very badly for large lests of argument and
option names and input argument lists.

PREPEND_CMNDLINE_ARGS()
+++++++++++++++++++++++

Utility function that prepends command-line arguments to a variable of
command-line options.

Usage::

  PREPEND_CMNDLINE_ARGS(<var> "<extraArgs>")

This function just prepends the command-line arguments in the string
``"<extraArgs>"`` but does not add an extra space if ``<var>`` is empty on
input.

PREPEND_GLOBAL_SET()
++++++++++++++++++++

Utility macro that prepends arguments to a global variable (reduces
boiler-plate code and mistakes).

Usage::

  PREPEND_GLOBAL_SET(<varName> <arg0> <arg1> ...)

NOTE: The variable ``<varName>`` must exist before calling this function.
To set it empty initially use `GLOBAL_NULL_SET()`_.

APPEND_SET()
++++++++++++

Utility function to append elements to a varible (reduces boiler-plate
code).

Usage::

  APPEND_SET(<varName> <arg0> <arg1> ...)

Just calls::

  LIST(APPEND <varName> <arg0> <arg1> ...)

PRINT_NONEMPTY_VAR()
++++++++++++++++++++

Print a defined variable giving its name then value only if it is not empty.

Usage::

   PRINT_NONEMPTY_VAR(<varName>)

Calls ``PRINT_VAR(<varName>)`` if ``${<varName>}`` is not empty.

PRINT_VAR()
+++++++++++

Unconditionally print a variable giving its name then value.

Usage::

  PRINT_VAR(<varName>)

This prints::

  MESSAGE("-- " "${VARIBLE_NAME}='${${VARIBLE_NAME}}'")

The variable ``<varName>`` can be defined or undefined or empty.  This uses
an explicit "-- " line prefix so that it prints nice even on Windows CMake.

REMOVE_GLOBAL_DUPLICATES()
++++++++++++++++++++++++++

Remove duplicate elements from a global list variable.

Usage::

  REMOVE_GLOBAL_DUPLICATES(<globalVarName>)

This function is necessary in order to preserve the "global" nature of the
variable.  If you just call LIST(REMOVE_DUPLICATES ...) it will actually
create a local variable of the same name and shadow the global variable!
That is a fun bug to track down!

SET_AND_INC_DIRS()
++++++++++++++++++

Set a variable to an include dir and call ``INCLUDE_DIRECTORIES()`` (removes
boiler plate).

Usage:

  SET_AND_INC_DIRS(<dirVarName> <includeDir>)

On output, this justs ``<dirVarName>`` to ``<includeDir>`` in the local
scope and calls ``INCLUDE_DIRECTORIES(<includeDir>)``.

SET_CACHE_ON_OFF_EMPTY()
++++++++++++++++++++++++

Usage::

  SET_CACHE_ON_OFF_EMPTY(<varName> <initialVal> "<docString>" [FORCE])

Sets a special string cache variable with possible values "", "ON", or
"OFF".  This results in a nice dropdown box in the CMake cache manipulation
GUIs.

SET_DEFAULT()
+++++++++++++

Give a local variable a default if a non-empty value is not already set.

Usage::

  SET_DEFAULT(<varName> <arg0> <arg1> ...)

If on input ``"${<varName>}"==""``, then ``<varName>`` is set to the given
default.  Otherwise, the existing non-empty value is preserved.

SET_DEFAULT_AND_FROM_ENV()
++++++++++++++++++++++++++

Set a default value for a local variable and override from an env var of the
same name if it is set.

Usage::

  SET_DEFAULT_AND_FROM_ENV(<varName> <defaultVal>)

First calls ``SET_DEFAULT(<varName> <defaultVal>)`` and then looks for an
environment variable named ``<varName>`` and if non-empty, then overrides
the value of ``<varName>``.

This macro is primarily used in CTest code to provide a way to pass in the
value of CMake variables.  Older versions of ``ctest`` did not support the
option ``-D <var>:<type>=<value>`` to allow varaibles to be set through the
commandline like ``cmake`` always allowed.

SPLIT()
+++++++

Split a string varible into a string array/list variable.

Usage::

  SPLIT("<inputStr>" "<sepStr>" <outputStrListVar>)

The ``<sepStr>`` string is used with ``STRING(REGEX ...)`` to replace all
occurrences of ``<sepStr>` in ``<inputStr>`` with ";" and writing into
``<outputStrListVar>``.

WARNING: ``<sepStr>`` is interpreted as a regular expression so keep that in
mind when considering special regex chars like ``'*'``, ``'.'``, etc!

TIMER_GET_RAW_SECONDS()
+++++++++++++++++++++++

Return the raw time in seconds since epoch, i.e., since 1970-01-01 00:00:00
UTC.

Usage::

  TIMER_GET_RAW_SECONDS(<rawSecondsVar>)

This function is used along with `TIMER_GET_REL_SECONDS()`_, and
`TIMER_PRINT_REL_TIME()`_ to time big chunks of CMake code for timing and
profiling purposes.  See `TIMER_PRINT_REL_TIME()`_ for more details and an
example.

NOTE: This function runs an external process to run the ``date`` command.
Therefsore, it only works on Unix/Linux type systems that have a standard
``date`` command.  Since this runs an external process, this function should
only be used to time very course grained operations (i.e. that take longer
than a second).

TIMER_GET_REL_SECONDS()
+++++++++++++++++++++++

Return the relative time between start and stop seconds.

Usage::

  TIMER_GET_REL_SECONDS(<startSeconds> <endSeconds> <relSecondsOutVar>)

This simple function computes the relative number of seconds between
``<startSeconds>`` and ``<endSeconds>`` (i.e. from
`TIMER_GET_RAW_SECONDS()`_) and sets the result in the local variable
``<relSecondsOutVar>``.

TIMER_PRINT_REL_TIME()
++++++++++++++++++++++

Print the relative time between start and stop timers in ``<min>m<sec>s``
format.

Usage:

  TIMER_PRINT_REL_TIME(<startSeconds> <endSeconds> "<messageStr>")

Differences the raw times ``<startSeconds>`` and ``<endSeconds>``
(i.e. gotten from `TIMER_GET_RAW_SECONDS()`_) and prints the time in
``<min>m<sec>s`` format.  This can only resolve times a second or greater
apart.  If the start and end times are less than a second then ``0m0s`` will
be printed.

This is meant to be used with `TIMER_GET_RAW_SECONDS()`_ to time expensive
blocks of CMake code like::

  TIMER_GET_RAW_SECONDS(REAL_EXPENSIVE_START)

  REAL_EXPENSIVE(...)

  TIMER_GET_RAW_SECONDS(REAL_EXPENSIVE_END)

  TIMER_PRINT_REL_TIME(${REAL_EXPENSIVE_START} ${REAL_EXPENSIVE_END}
     "REAL_EXPENSIVE() time")

This will print something like::

  REAL_EXPENSIVE() time: 0m5s

Again, don't try to time something that takes less than 1 second as it will
be recored as ``0m0s``.
  
UNITTEST_COMPARE_CONST()
++++++++++++++++++++++++

Perform a single unit test equality check and update overall test statistics

Usage::

  UNITTEST_COMPARE_CONST(<varName> <expectedValue>)

If ``${<varName>} == <expectedValue>``, then the check passes, otherwise it
fails.  This prints the variable name and values and shows the test result.

This updates the global variables ``UNITTEST_OVERALL_NUMRUN``,
``UNITTEST_OVERALL_NUMPASSED``, and ``UNITTEST_OVERALL_PASS`` which are used
by the unit test harness system to assess overall pass/fail.

UNITTEST_STRING_REGEX()
+++++++++++++++++++++++

Perform a series regexes of given strings and update overall test statistics.

Usage::

  UNITTEST_STRING_REGEX(
    <inputString>
    REGEX_STRINGS <str0> <str1> ...
    )

If the ``<inputString>`` matches all of the of the regexs ``<str0>``,
''<str1>``, ..., then the test passes.  Otherwise it fails.

This updates the global variables ``UNITTEST_OVERALL_NUMRUN``,
``UNITTEST_OVERALL_NUMPASSED``, and ``UNITTEST_OVERALL_PASS`` which are used
by the unit test harness system to assess overall pass/fail.

UNITTEST_FILE_REGEX()
+++++++++++++++++++++

Perform a series regexes of given strings and update overall test statistics.

Usage::

  UNITTEST_FILE_REGEX(
    <inputFileName>
    REGEX_STRINGS <str1> <str2> ...
    )

The contents of ``<inputFileName>`` are read into a string and then passed
to `UNITTEST_STRING_REGEX()`_ to assess pass/fail.

UNITTEST_FINAL_RESULT()
+++++++++++++++++++++++

Print final statstics from all tests and assert final pass/fail

Usage::

  UNITTEST_FINAL_RESULT(<expectedNumPassed>)

If ``${UNITTEST_OVERALL_PASS}==TRUE`` and ``${UNITTEST_OVERALL_NUMPASSED} ==
<expectedNumPassed>``, then the overall test program is determined to have
passed and string::

 "Final UnitTests Result: PASSED"

is printed.  Otherwise, the overall tets program is determined to have
failed, the string::

 "Final UnitTests Result: FAILED"

is printed and ``MESSAGE(SEND_ERROR "FAIL")`` is called.

The reason that we require passing in the expected number of passed tests is
an an extra precaution to make sure that important unit tests are not left
out.  CMake is a loosely typed language and it pays to be a little paranoid.

