.. WARNING: The file UtilsMacroFunctionDoc.rst is autogenerated from
.. the file UtilsMacroFunctionDocTemplate.rst in the script
.. generate-dev-guide.sh.  Only the file UtilsMacroFunctionDoc.rst
.. should be directly modified!

ADD_SUBDIRECTORIES()
--------------------

Macro that adds a list of subdirectories all at once (removed boiler-place
code).

Usage::

  ADD_SUBDIRECTORIES(<dir1> <dir2> ...)

ADVANCED_OPTION()
-----------------

Macro that sets an option and marks it as advanced (removes boiler-plate and
duplication).

Usage::

  ADVANCED_OPTION(<varName> [other arguments])

This is identical to::

  ADVANCED_OPTION(<varName> [other arguments])
  MARK_AS_ADVANCED(<varName>)

ADVANCED_SET()
--------------

Macro that sets a variable and marks it as advanced (removes boiler-plate
and duplication).

Usage::

  ADVANCED_SET(<varName> [other arguments])

This is identical to::

  ADVANCED_SET(<varName> [other arguments])
  MARK_AS_ADVANCED(<varName>)

APPEND_CMNDLINE_ARGS()
----------------------

Utility function that appends command-line arguments to a variable of
command-line options.

Usage::

  APPEND_CMNDLINE_ARGS(<var> "<extraArgs>")

This function just appends the command-line arguments in the string
``"<extraArgs>"`` but does not add an extra space if ``<var>`` is empty on
input.

APPEND_GLOB()
-------------

Utility macro that does a ``FILE(GLOB ...)`` and appends to an existing list
(removes boiler-plate code).

Usage::

  APPEND_GLOB(<fileListVar> <glob0> <glob1> ...)

On output, ``<fileListVar>`` will have the list of glob files appended.

APPEND_GLOBAL_SET()
-------------------

Utility macro that appends arguments to a global variable (reduces
boiler-plate code and mistakes).

Usage::

  APPEND_GLOBAL_SET(<varName> <arg0> <arg1> ...)

APPEND_SET()
------------

Utility function to append elements to a varible (reduces boiler-plate
code).

Usage::

  APPEND_SET(<varName> <arg0> <arg1> ...)

Just calls::

  LIST(APPEND <varName> <arg0> <arg1> ...)

APPEND_STRING_VAR()
-------------------

Append strings to an existing string variable (reduces boiler-place code and
reduces mistakes).

Usage::

  APPEND_STIRNG_VAR(<stringVar> "<string1>" "<string2>" ...)

Note that the usage of the characters ``'['``, ``']'``, ``'{'``, ``'}'`` are
taken by CMake to bypass the meaning of ';' to separate string characters.

If you want to ignore the meaning of these special characters and are okay with
just adding one string at a time use `APPEND_STRING_VAR_EXT()`_.

APPEND_STRING_VAR_EXT()
-----------------------

Append a single string to an existing string variable, ignoring ';' (reduces
boiler-place code and reduces mistakes).

Usage::

  APPEND_STIRNG_VAR_EXT(<stringVar> "<string>")

Simply sets ``<stringVar> = "${<stringVar>}<string>"``.

APPEND_STRING_VAR_WITH_SEP()
----------------------------

Append strings to a given string varible, joining them using a seperator.

Usage::

  APPEND_STRING_VAR_WITH_SEP(<stringVar> "<sepStr>" "<str0>" "<str>" ...)

Each of the strings ``<stri>`` are appended to ``<stringVar>`` using the
separation string ``<sepStr>``.

ASSERT_DEFINED()
----------------

Assert that a varaible is defined and if not call ``MESSAGE(SEND_ERROR ...)``.

Usage::

  ASSERT_DEFINED(<varName>)

This is used to get around the problem of CMake not asserting the
defreferencing of undefined varibles.  For example, how do you know if you
did not mispell the name of a varible in an if statement like::

  IF (SOME_VARBLE)
    ...
  ENDIF()

?  If you mispelled the varible ``SOME_VARBLE`` (which you likely did in
 this case), the the if statement will always be false.  To avoid this
 problem when you always expect the explicitly set, instead do::

  ASSERT_DEFINED(SOME_VARBLE)
  IF (SOME_VARBLE)
    ...
  ENDIF()

Now if you misspell the varible, it will asset and stop processing.  This is
not a perfect solution since you can mispell the varible name in the
following if statemnt but typically you would always just copy and paste
between the two statements so they are always the same.  This is the best we
can do in CMake unfortunately.

COMBINED_OPTION()
-----------------

Set up a bool cache variable (i.e. an option) based on a set of dependent
options.

Usage::

  COMBINED_OPTION( <combinedOptionName>
    DEP_OPTIONS_NAMES <depOpName0> <depOptName1> ...
    DOCSTR "<docstr0>" "<docstr1" ...
    )

This sets up a bool cache variable ``<combinedOptionName>`` which is
defaulted to ``ON`` if all of the listed dependent option varaibles
``<depOpName0>``, ``<depOptName1>``, ... are all ``ON``.  However, if
``<combinedOptionName>`` is set to ``ON`` by the user and not all of the
dependent option varibles are also true, this results in a fatal eror and
alll processing stops.

This is used by a CMake project to by default automatically turn on a
feature that requires a set of other features to also be turned on but
allows a user to disable the feature if desired.

CONCAT_STRINGS()
----------------

Concatenate a set of string argumnets.

Usage::

  CONCAT_STRINGS(<outputVar> "<str0>" "<str1>" ...)

On output, ``<outputVar>`` is set to ``"<str0><str1>..."``.

DUAL_SCOPE_APPEND_CMNDLINE_ARGS()
---------------------------------

Utility function that appends command-line arguments to a variable of
command-line options and sets the result in current scope and parent scope.

Usage::

  DUAL_SCOPE_APPEND_CMNDLINE_ARGS(<var> "<extraArgs>")

Just calls `APPEND_CMNDLINE_ARGS()`_ and then ``SET(<var> ${<var>} PARENT_SCOPE)``.

DUAL_SCOPE_PREPEND_CMNDLINE_ARGS()
----------------------------------

Utility function that prepends command-line arguments to a variable of
command-line options and sets the result in current scope and parent scope.

Usage::

  DUAL_SCOPE_PREPEND_CMNDLINE_ARGS(<var> "<extraArgs>")

Just calls `PREPEND_CMNDLINE_ARGS()`_ and then ``SET(<var> ${<var>} PARENT_SCOPE)``.

DUAL_SCOPE_SET()
----------------

Macro that sets a variable name both in the current scope and the
parent scope.

Usage::

   DUAL_SCOPE_SET(<varName> [other args])

It turns out that when you call ``ADD_SUBDIRECTORY(<someDir>)`` or enter a
FUNCTION that CMake actaully creates a copy of all of the regular non-cache
varaibles in the current scope in order to create a new set of variables for
the ``CMakeLists.txt`` file in ``<someDir>``.  This means that if you call
``SET(SOMEVAR Blah PARENT_SCOPE)`` that it will not affect the value of
``SOMEVAR`` in the current scope.  This macro therefore is designed to set
the value of the variable in the current scope and the parent scope in one
shot to avoid confusion.

Global variables are different.  When you move to a subordinate
``CMakeLists.txt`` file or enter a function, a local copy of the variable is
*not* created.  If you set the value name locally, it will shadow the global
variable.  However, if you set the globlal value with SET(SOMEVAR someValue
CACHE INTERNAL ""), then the value will get changed in the current
subordinate scope and in all parent scopes all in one shot!

GLOBAL_NULL_SET()
-----------------

Set a variable as a null internal global (cache) variable (removes boiler
plate).

Usage::

  GLOBAL_NULL_SET(<varName>)

This just calls::

  SET(<varName> "" CACHE INTERNAL "")

GLOBAL_SET()
------------

Set a variable as an internal global (cache) variable (removes boiler
plate).

Usage::

  GLOBAL_SET(<varName> [other args])

This just calls::

  SET(<varName> [other args] CACHE INTERNAL "")

PARSE_ARGUMENTS()
-----------------

Parse a set of macro/functon input arguments into different lists.  This
allows the easy implementation of keyword-based user-defined macros and
functions.

Usage::

  PARSE_ARGUMENTS(
    <prefix>  <argNamesList>  <optionNamesList>
    <inputArgsList>
    )

Arguments to this macro:

  ``<prefix>``

    Prefix ``<prefix>_`` added the list and option variables created listed
    in ``<argNamesList>`` and ``<optionNamesList>``.

  ``<argNamesList>``

    Quoted array of list arguments (e.g. ``"<argName0>;<argName1>;..."``).
    For each varaible name ``<argNamei>``, a local varible will be created
    in the current scope with the name ``<prefix>_<argNamei>`` which gives
    the list of varibles parsed out of ``<inputArgsList>``.

  ``<optionNamesList>``

    Quoted array of list arguments (e.g. ``"<optName0>;<optName1>;..."``).
    For each varaible name ``<optNamei>``, a local varible will be created
    in the current scope with the name ``<prefix>_<optNamei>`` that is
    either set to ``TRUE`` or ``FALSE`` depending if ``<optNamei>`` apears
    in ``<inputArgsList>`` or not.

  ``<inputArgsList>``

    List of arguments keyword-based arguments passed in for the outer macro
    or function to be parsed out into the different argument and option
    lists.

What this macro does is very simple yet very powerful.  What it does is to
allow you to create your own keyword-based macros and functions like CMake
has.

For example, consider the following user-defined macro that uses both
positional and keyword-based arguments using ``PARSE_ARGUMENTS()``::

  MACRO(PARSE_SPECIAL_VARS  BASE_NAME)

    PARSE_ARGUMENTS(
      #prefix
      ${BASE_NAME}
      #lists
      "ARG0;ARG1;ARG2"
      #options
      "OPT0;OPT1"
      ${ARGN}
      )

  ENDMACRO()

Calling this macro as::

  PARSE_SPECIAL_VARS(MyVar ARG0 a b ARG2 c OPT1)

sets the following varibles in the current scopt:

* ``MyVar_ARG0="a;b"``
* ``MyVar_ARG1=""``
* ``MyVar_ARG2="c"``
* ``MyVar_OPT0="FALSE"``
* ``MyVar_OPT1="TRUE"``

This allows you to define user-defined macros and functions that have a
mixture of positional arguments and keyword-based arguments like you can do
in other languages.  The keyword-based arguments can be passed in in any
order and those that are missing are empty (or false) by default.

If ``PARSE_ARGUMENTS_DUMP_OUTPUT_ENABLED``is set to ``TRUE``, then a bunch
of detailed debug info will be printed.  This should only lbe used in the
most desparate of debug situations because it will print a *lot* of output!

**PERFORMANCE:** This function will scale as::

  O( (len(<argNamesList>) * len(<optionNamesList>)) * len(<inputArgsList>) )

Therefore, this could scale very badly for large lests of argument and
option names and input argument lists.

PREPEND_CMNDLINE_ARGS()
-----------------------

Utility function that prepends command-line arguments to a variable of
command-line options.

Usage::

  PREPEND_CMNDLINE_ARGS(<var> "<extraArgs>")

This function just prepends the command-line arguments in the string
``"<extraArgs>"`` but does not add an extra space if ``<var>`` is empty on
input.

