.. WARNING: The file TribitsDetailedMacroFunctionDoc.rst is autogenerated from
.. the file TribitsDetailedMacroFunctionDocTemplate.rst in the script
.. generate-dev-guide.sh.  Only the file TribitsDetailedMacroFunctionDoc.rst
.. should be directly modified!

TRIBITS_ADD_ADVANCED_TEST()
+++++++++++++++++++++++++++

Function that creates an advanced test defined by stringing together one or
more executables and/or commands that is run as a ``cmake -P`` script with
very flexible pass/fail criteria.

Usage::

  TRIBITS_ADD_ADVANCED_TEST(
    <testName>
    TEST_0 (EXEC <execTarget0> | CMND <cmndExec0>) ...
    [TEST_1 (EXEC <execTarget1> | CMND <cmndExec1>) ...]
    ...
    [TEST_N (EXEC <execTargetN> | CMND <cmndExecN>) ...]
    [OVERALL_WORKING_DIRECTORY (<overallWorkingDir> | TEST_NAME)]
    [FAIL_FAST]
    [KEYWORDS <keyword1> <keyword2> ...]
    [COMM [serial] [mpi]]
    [OVERALL_NUM_MPI_PROCS <overallNumProcs>]
    [CATEGORIES <category0> <category1> ...]
    [HOST <host0> <host1> ...]
    [XHOST <host0> <host1> ...]
    [HOSTTYPE <hosttype0> <hosttype1> ...]
    [XHOSTTYPE <hosttype0> <hosttype1> ...]
    [FINAL_PASS_REGULAR_EXPRESSION <regex> |
      FINAL_FAIL_REGULAR_EXPRESSION <regex>]
    [ENVIRONMENT <var1>=<value1> <var2>=<value2> ...]
    [TIMEOUT <maxSeconds>]
    )

This function allows one to add a single CTest test that is actually a
sequence of one or more separate commands strung together in some way to
define the final pass/fail. One will want to use this function to add a test
instead of `TRIBITS_ADD_TEST()`_ when one needs to run more than one
command, or one needs more sophisticated checking of the test result other
than just grepping STDOUT (e.g. by running separate post-processing programs
to examine output files).

Each atomic test case is either a package-built executable or just a basic
command.  An atomic test command block ``TEST_<idx>`` (i.e. ``TEST_0``,
``TEST_1``, ...) takes the form::

  TEST_<idx>
     (EXEC <exeRootName> [NOEXEPREFIX] [NOEXESUFFIX] [ADD_DIR_TO_NAME]
            [DIRECTORY <dir>]
        | CMND <cmndExec>)
     [ARGS <arg1> <arg2> ... <argn>]
     [MESSAGE "<message>"]
     [WORKING_DIRECTORY <workingDir>]
     [NUM_MPI_PROCS <numProcs>]
     [OUTPUT_FILE <outputFile>]
     [NO_ECHO_OUTPUT]]
     [PASS_ANY
       | PASS_REGULAR_EXPRESSION "<regex>"
       | PASS_REGULAR_EXPRESSION_ALL "<regex1>" "<regex2>" ... "<regexn>"
       | FAIL_REGULAR_EXPRESSION "<regex>"
       | STANDARD_PASS_OUTPUT
       ]

By default, each and every atomic test or command needs to pass (as defined below) in
order for the overall test to pass.

*Sections:*

* `Overall Arguments (TRIBITS_ADD_ADVANCED_TEST())`_
* `TEST_<idx> Test Blocks and Arguments (TRIBITS_ADD_ADVANCED_TEST())`_
* `Overall Pass/Fail (TRIBITS_ADD_ADVANCED_TEST())`_
* `Argument Parsing and Ordering (TRIBITS_ADD_ADVANCED_TEST())`_
* `Implementation Details (TRIBITS_ADD_ADVANCED_TEST())`_
* `Setting Additional Test Properties (TRIBITS_ADD_ADVANCED_TEST())`_
* `Running multiple tests at the same time (TRIBITS_ADD_ADVANCED_TEST())`_
* `Disabling Tests Externally (TRIBITS_ADD_ADVANCED_TEST())`_
* `Debugging and Examining Test Generation (TRIBITS_ADD_ADVANCED_TEST())`_

.. _Overall Arguments (TRIBITS_ADD_ADVANCED_TEST()):

**Overall Arguments (TRIBITS_ADD_ADVANCED_TEST())**

Below, some of the overall arguments are described.  The rest of the overall
arguments that control overall pass/fail are described in `Overall Pass/Fail
(TRIBITS_ADD_ADVANCED_TEST())`_.  (NOTE: All of these arguments must be
listed outside of the ``TEST_<idx>`` blocks, see `Argument Parsing and
Ordering (TRIBITS_ADD_ADVANCED_TEST())`_).

  ``<testName>``

    The name of the test (which will have ``${PACKAGE_NAME}_`` prepended to
    the name) that will be used to name the output CMake script file as well
    as the CTest test name passed into ``ADD_TEST()``.  This must be the
    first argument to this function.

  ``OVERALL_WORKING_DIRECTORY <overallWorkingDir>``

    If specified, then the working directory ``<overallWorkingDir>`` will be
    created and all of the test commands by default will be run from within
    this directory.  If the value ``<overallWorkingDir>=TEST_NAME`` is
    given, then the working directory will be given the name
    ``${PACKAGE_NAME}_<testName>``.  If the directory
    ``<overallWorkingDir>`` exists before the test runs, it will be deleted
    and created again.  Therefore, if one wants to preserve the contents of
    this directory between test runs then one needs to copy the files it
    contains somewhere else.  This is a good option to use if the commands
    create intermediate files and one wants to make sure they get deleted
    before the test cases are run again.  This is also a very useful option
    to use if multiple tests are defined in the same ``CMakeLists.txt`` file
    that read/write files with the same name.

  ``FAIL_FAST``

    If specified, then the remaining test commands will be aborted when any
    test command fails.  Otherwise, all of the test cases will be run.

  ``RUN_SERIAL``

    If specified then no other tests will be allowed to run while this test
    is running.  This is useful for devices (like CUDA cards) that require
    exclusive access for processes/threads.  This just sets the CTest test
    property ``RUN_SERIAL`` using the built-in CMake function
    ``SET_TESTS_PROPERTIES()``.

  ``COMM [serial] [mpi]``

    If specified, selects if the test will be added in serial and/or MPI
    mode.  See the ``COMM`` argument in the script
    `TRIBITS_ADD_TEST()`_ for more details.

  ``OVERALL_NUM_MPI_PROCS <overallNumProcs>``

    If specified, gives the default number of MPI processes that each
    executable command runs on.  If ``<numProcs>`` is greater than
    ``${MPI_EXEC_MAX_NUMPROCS}`` then the test will be excluded.  If not
    specified, then the default number of processes for an MPI build will be
    ``${MPI_EXEC_DEFAULT_NUMPROCS}``.  For serial builds, this argument is
    ignored.  This also results in the test property ``PROCESSORS`` being
    set to ``<overallNumProcs>`` (see `Running multiple tests at the same
    time (TRIBITS_ADD_ADVANCED_TEST())`_).  **WARNING!** If just running a
    serial script or other command, then the property ``PROCESSORS`` will
    still get set to ``${MPI_EXEC_DEFAULT_NUMPROCS}`` so in order to avoid
    CTest unnecessarily resolving ``${MPI_EXEC_DEFAULT_NUMPROCS}`` processes
    for a serial non-MPI test, then one must explicitly pass in
    ``MPI_EXEC_DEFAULT_NUMPROCS 1``!

  ``CATEGORIES <category0> <category1> ...``

    Gives the `Test Test Categories`_ for which this test will be added.
    See `TRIBITS_ADD_TEST()`_ for more details.

  ``HOST <host0> <host1> ...``

    The list of hosts for which to enable the test (see
    `TRIBITS_ADD_TEST()`_).

  ``XHOST <host0> <host1> ...``

    The list of hosts for which **not** to enable the test (see
    `TRIBITS_ADD_TEST()`_).

  ``HOSTTYPE <hosttype0> <hosttype1> ...``

    The list of host types for which to enable the test (see
    `TRIBITS_ADD_TEST()`_).

  ``XHOSTTYPE <hosttype0> <hosttype1> ...``

    The list of host types for which **not** to enable the test (see
    `TRIBITS_ADD_TEST()`_).

  ``ENVIRONMENT <var1>=<value1> <var2>=<value2> ..``.

    If passed in, the listed environment variables will be set before
    calling the test.  This is set using the built-in CTest test property
    ``ENVIRONMENT``.

  ``TIMEOUT <maxSeconds>``

    If passed in, gives maximum number of seconds the test will be allowed
    to run before being timed-out (see `TRIBITS_ADD_TEST()`_).  This is for
    the full CTest test, not individual ``TEST_<idx>`` commands!

.. _TEST_<idx> Test Blocks and Arguments (TRIBITS_ADD_ADVANCED_TEST()):

**TEST_<idx> Test Blocks and Arguments (TRIBITS_ADD_ADVANCED_TEST())**

Each test command block ``TEST_<idx>`` runs either a package-built test
executable or some general command executable and is defined as either
``EXEC <exeRootName>`` or ``CMND <cmndExec>`` with the arguments:

  ``EXEC <exeRootName> [NOEXEPREFIX] [NOEXESUFFIX] [ADD_DIR_TO_NAME]
  [DIRECTORY <dir>]``

    If ``EXEC`` is specified, then ``<exeRootName>`` gives the root name of
    an executable target that will be run as the command.  The full
    executable name and path is determined in exactly the same way it is in
    the `TRIBITS_ADD_TEST()`_ function (see `Determining the Executable or
    Command to Run (TRIBITS_ADD_TEST())`_).  If this is an MPI build, then
    the executable will be run with MPI using ``NUM_MPI_PROCS <numProcs>``
    or ``OVERALL_NUM_MPI_PROCS <overallNumProcs>`` (if ``NUM_MPI_PROCS`` is
    not set for this test case).  If the maximum number of MPI processes
    allowed is less than this number of MPI processes, then the test will
    *not* be run.  Note that ``EXEC <exeRootName>`` when ``NOEXEPREFIX`` and
    ``NOEXESUFFIX`` are specified is basically equivalent to ``CMND
    <cmndExec>`` except that in an MPI build, ``<exeRootName>`` is always
    run using MPI.  In this case, one can pass in ``<exeRootName>`` to any
    command one would like and it will get run with MPI in MPI mode just
    link any other MPI-enabled built executable.

  ``CMND <cmndExec>``

    If ``CMND`` is specified, then ``<cmndExec>`` gives the executable for a
    command to be run.  In this case, MPI will never be used to run the
    executable even when configured in MPI mode
    (i.e. ``TPL_ENABLE_MPI=ON``).  If one wants to run an arbitrary command
    using MPI, use ``EXEC <fullPathToCmndExec> NOEXEPREFIX NOEXESUFFIX``
    instead.

By default, the output (stdout/stderr) for each test command is captured and
is then echoed to stdout for the overall test.  This is done in order to be
able to grep the result to determine pass/fail.

Other miscellaneous arguments for each ``TEST_<idx>`` block include:

  ``DIRECTORY <dir>``

    If specified, then the executable is assumed to be in the directory
    given by relative ``<dir>``.  See `TRIBITS_ADD_TEST()`_.

  ``MESSAGE "<message>"``

    If specified, then the string in ``"<message>"`` will be printed before
    this test command is run.  This allows adding some documentation about
    each individual test invocation to make the test output more
    understandable.

  ``WORKING_DIRECTORY <workingDir>``

    If specified, then the working directory ``<workingDir>`` will be
    created and the test will be run from within this directory.  If the
    value ``<workingDir> = TEST_NAME`` is given, then the working directory
    will be given the name ``${PACKAGE_NAME}_<testName>``.  If the directory
    ``<workingDir>`` exists before the test runs, it will be deleted and
    created again.  Therefore, if one wants to preserve the contents of this
    directory between test runs then one needs to copy the given file
    somewhere else.  Using a different ``WORKING_DIRECTORY`` for individual
    test commands allows creating independent working directories for each
    test case.  This would be useful if a single
    ``OVERALL_WORKING_DIRECTORY`` was not sufficient for some reason.

  ``NUM_MPI_PROCS <numProcs>``

    If specified, then ``<numProcs>`` is the number of processors used for
    MPI executables.  If not specified, this will default to
    ``<overallNumProcs>`` from ``OVERALL_NUM_MPI_PROCS <overallNumProcs>``.

  ``OUTPUT_FILE <outputFile>``

    If specified, then stdout and stderr for the test case will be sent to
    ``<outputFile>``.  By default, the contents of this file will **also**
    be printed to STDOUT unless ``NO_ECHO_OUT`` is passed as well.

  ``NO_ECHO_OUTPUT``

    If specified, then the output for the test command will not be echoed to
    the output for the entire test command.

By default, an atomic test line is assumed to pass if the executable or
commands returns a non-zero value to the shell.  However, a test case can
also be defined to pass based on:

  ``PASS_ANY``

    If specified, the test command will be assumed to pass regardless of
    the return value or any other output.  This would be used when a command
    that is to follow will determine pass or fail based on output from this
    command in some way.

  ``PASS_REGULAR_EXPRESSION "<regex>"``

    If specified, the test command will be assumed to pass if it matches the
    given regular expression.  Otherwise, it is assumed to fail.

  ``PASS_REGULAR_EXPRESSION_ALL "<regex1>" "<regex2>" ... "<regexn>"``

    If specified, the test command will be assumed to pass if the output
    matches all of the provided regular expressions.  Note that this is not
    a capability of raw ctest and represents an extension provided by
    TriBITS.

  ``FAIL_REGULAR_EXPRESSION "<regex>"``

    If specified, the test command will be assumed to fail if it matches the
    given regular expression.  Otherwise, it is assumed to pass.

  ``STANDARD_PASS_OUTPUT``

    If specified, the test command will be assumed to pass if the string
    expression "Final Result: PASSED" is found in the output for the test.

All of the arguments for a test block ``TEST_<idx>`` must appear directly
below their ``TEST_<idx>`` argument and before the next test block (see
`Argument Parsing and Ordering (TRIBITS_ADD_ADVANCED_TEST())`_).

.. _Overall Pass/Fail (TRIBITS_ADD_ADVANCED_TEST()):

**Overall Pass/Fail (TRIBITS_ADD_ADVANCED_TEST())**

By default, the overall test will be assumed to pass if it prints::

  "OVERALL FINAL RESULT: TEST PASSED"

However, this can be changed by setting one of the following optional arguments:

  ``FINAL_PASS_REGULAR_EXPRESSION <regex>``

    If specified, the test will be assumed to pass if the output matches
    ``<regex>``.  Otherwise, it will be assumed to fail.

  ``FINAL_FAIL_REGULAR_EXPRESSION <regex>``

    If specified, the test will be assumed to fail if the output matches
    ``<regex>``.  Otherwise, it will be assumed to fail.

.. _Argument Parsing and Ordering (TRIBITS_ADD_ADVANCED_TEST()):

**Argument Parsing and Ordering (TRIBITS_ADD_ADVANCED_TEST())**

The basic tool used for parsing the arguments to this function is the macro
`PARSE_ARGUMENTS()`_ which has a certain set of behaviors.  The parsing
using `PARSE_ARGUMENTS()`_ is actually done in two phases.  There is a
top-level parsing of the "overall" arguments listed in `Overall Arguments
(TRIBITS_ADD_ADVANCED_TEST())`_ that also pulls out the test blocks.  Then
there is a second level of parsing using ``PARSE_ARGUMENTS()`` for each of
the ``TEST_<idx>`` blocks.  Because of this usage, there are a few
restrictions that one needs to be aware of when using
``TRIBITS_ADD_ADVANCED_TEST()``.  This short sections tries to explain the
behaviors and what is allowed and what is not allowed.

For the most part, the "overall" arguments and the arguments inside of any
individual ``TEST_<idx>`` blocks can be listed can appear in any order but
there are restrictions related to the grouping of overall arguments and
``TEST_<idx>`` blocks which are as follows:

* The ``<testName>`` argument must be the first listed (it is the only
  positional argument).

* The test cases ``TEST_<idx>`` must be listed in order (i.e. ``TEST_0
  ... TEST_1 ...``) and the test cases must be consecutive integers
  (e.g. can't jump from ``TEST_5`` to ``TEST_7``).

* All of the arguments for a test case must appear directly below its
  ``TEST_<idx>`` keyword and before the next ``TEST_<idx+1>`` keyword or
  before any trailing overall keyword arguments.

* None of the overall arguments (e.g. ``CATEGORIES``) can be listed inside
  of a ``TEST_<idx>`` block but otherwise can be listed before or after all
  of the ``TEST_<idx>`` blocks.  (NOTE: The current implementation will
  actually allow overall arguments to be listed after all of the local
  arguments before the next TEST_<idx> block but this is confusing and will
  not be allowed in a future implementation).

Other than that, the keyword arguments and options can appear in any order.

.. ToDo: Add some examples of bad argument ordering and what will happen.

.. _Implementation Details (TRIBITS_ADD_ADVANCED_TEST()):

**Implementation Details (TRIBITS_ADD_ADVANCED_TEST())**

Since raw CTest does not support the features provided by this function, the
way an advanced test is implemented is that a ``cmake -P`` script with the
name ``${PACKAGE_NAME}_<testName>.cmake`` gets created in the current binary
directory that then gets added to CTest using::

  ADD_TEST(${PACKAGE_NAME}_<testName>
    cmake [other options] -P ${PACKAGE_NAME}_<testName>.cmake)

This ``cmake -P`` script then runs the various test cases and checks the
pass/fail for each case to determine overall pass/fail and implement other
functionality described above.

.. _Setting Additional Test Properties (TRIBITS_ADD_ADVANCED_TEST()):

**Setting Additional Test Properties (TRIBITS_ADD_ADVANCED_TEST())**

After this function returns, if the test gets added using ``ADD_TEST()``,
then additional properties can be set and changed using
``SET_TESTS_PROPERTIES(${PACKAGE_NAME}_<testName> ...)``.  Therefore, any
tests properties that are not directly supported by this function and passed
through the argument list to this wrapper function can be set in the outer
``CMakeLists.txt`` file after the call to ``TRIBITS_ADD_ADVANCED_TEST()``.

.. _Running multiple tests at the same time (TRIBITS_ADD_ADVANCED_TEST()):

**Runnning multiple tests at the same time (TRIBITS_ADD_ADVANCED_TEST())**

Just as with `TRIBITS_ADD_TEST()`_, setting ``NUM_MPI_PROCS <numProcs>`` or
``OVERALL_NUM_MPI_PROCS <numOverallProcs>`` will set the ``PROCESSORS``
CTest property to allow CTest to schedule and run mutiple tests at the same
time when ``'ctest -j<N>'`` is used (see `Running multiple tests at the same
time (TRIBITS_ADD_TEST())`_).

.. _Disabling Tests Externally (TRIBITS_ADD_ADVANCED_TEST()):

**Disabling Tests Externally (TRIBITS_ADD_ADVANCED_TEST())**

The test can be disabled externally by setting the CMake cache variable
``${FULL_TEST_NAME}_DISABLE=TRUE``.  This allows tests to be disabled on a
case-by-case basis.  The name ``${FULL_TEST_NAME}`` must be the *exact* name
that shows up in ``ctest -N`` when running the test.

.. _Debugging and Examining Test Generation (TRIBITS_ADD_ADVANCED_TEST()):

**Debugging and Examining Test Generation (TRIBITS_ADD_ADVANCED_TEST())**

In order to see if the test gets added and to debug some issues in test
creation, one can set the cache variable
``${PROJECT_NAME}_VERBOSE_CONFIGURE=ON``.  This will result in the printout
of some information about the test getting added or not.

Likely the best way to debugging test generation using this function is to
examine the generated file ``${PACKAGE_NAME}_<testName>.cmake`` in the
current binary directory (see `Implementation Details
(TRIBITS_ADD_ADVANCED_TEST())`_) and the generated ``CTestTestfile.cmake``
file that should list this test case.

TRIBITS_ADD_DEBUG_OPTION()
++++++++++++++++++++++++++

Add the standard cache variable option ``${PACKAGE_NAME}_ENABLE_DEBUG`` for
the package.

Usage::

  TRIBITS_ADD_DEBUG_OPTION()

This option is given the default ``${${PROJECT_NAME}_ENABLE_DEBUG}`` and if
true, will set the variable ``HAVE_${PACKAGE_NAME_UC}_DEBUG`` (to be used in
the package's configured header file).  This macro is typically called in
the package's `<packageDir>/CMakeLists.txt`_ file.

TRIBITS_ADD_EXAMPLE_DIRECTORIES()
+++++++++++++++++++++++++++++++++
 
Macro called to conditionally add a set of example directories for an SE
package.

Usage::

   TRIBITS_ADD_EXAMPLE_DIRECTORIES(<dir1> <dir2> ...)

This macro typically is called from the top-level
`<packageDir>/CMakeLists.txt`_ file for which all subdirectories are all
"examples" according to standard package layout.

This macro can be called several times within a package as desired to break
up example directories any way one would like.

Currently, all it does macro does is to call ``ADD_SUBDIRECTORY(<diri>)`` if
``${PACKAGE_NAME}_ENABLE_EXAMPLES`` or
``${PARENT_PACKAGE_NAME}_ENABLE_EXAMPLES`` are true. However, this macro may
be extended in the future in order to modify behavior related to adding
tests and examples in a uniform way.

TRIBITS_ADD_EXECUTABLE()
++++++++++++++++++++++++

Function used to create an executable (typically for a test or example),
using the built-in CMake command ``ADD_EXECUTABLE()``.

Usage::

  TRIBITS_ADD_EXECUTABLE(
    <exeRootName>  [NOEXEPREFIX]  [NOEXESUFFIX]  [ADD_DIR_TO_NAME]
    SOURCES <src0> <src1> ...
    [CATEGORIES <category0>  <category1> ...]
    [HOST <host0> <host1> ...]
    [XHOST <host0> <host1> ...]
    [HOSTTYPE <hosttype0> <hosttype1> ...]
    [XHOSTTYPE <hosttype0> <hosttype1> ...]
    [DIRECTORY <dir>]
    [DEPLIBS <lib0> <lib1> ...]
    [COMM [serial] [mpi]]
    [LINKER_LANGUAGE (C|CXX|Fortran)]
    [DEFINES -D<define0> -D<define1> ...]
    [INSTALLABLE]
    )

*Sections:*

* `Formal Arguments (TRIBITS_ADD_EXECUTABLE())`_
* `Executable and Target Name (TRIBITS_ADD_EXECUTABLE())`_
* `Additional Executable and Source File Properties (TRIBITS_ADD_EXECUTABLE())`_
* `Install Target (TRIBITS_ADD_EXECUTABLE())`_

.. _Formal Arguments (TRIBITS_ADD_EXECUTABLE()):

**Formal Arguments (TRIBITS_ADD_EXECUTABLE())**

  ``<exeRootName>``

    The root name of the exectuable (and CMake target) (see `Executable and
    Target Name (TRIBITS_ADD_EXECUTABLE())`_).  This must be the first
    argument.

  ``NOEXEPREFIX``

    If passed in, then ``${PACKAGE_NAME}_`` is not added the beginning of
    the executable name (see `Executable and Target Name
    (TRIBITS_ADD_EXECUTABLE())`_).

  ``NOEXESUFFIX``

    If passed in, then ``${${PROJECT_NAME}_CMAKE_EXECUTABLE_SUFFIX}`` and
    not added to the end of the executable name (see `Executable and
    Target Name (TRIBITS_ADD_EXECUTABLE())`_).

  ``ADD_DIR_TO_NAME``

    If passed in, the directory path relative to the package's base
    directory (with "/" replaced by "_") is added to the executable name
    (see `Executable and Target Name (TRIBITS_ADD_EXECUTABLE())`_).  This
    provides a simple way to create unique test exectuable names inside of a
    given TriBITS package.  Only test executables in the same directory
    would need to have unique ``<execRootName>`` passed in.

  ``SOURCES <src0> <src1> ...``

    Gives the source files that will be compiled into the built executable.
    By default, these sources are assumed to be in the current working
    directory (or can contain the relative path or absolute path).  If
    ``<srci>`` is an absolute path, then that full file path is used.  This
    list of sources (with adjusted directory path) are passed into
    ``ADD_EXECUTABLE(<fullExeName> ... )``.  After calling this function,
    the properties of the source files can be altered using the built-in
    CMake command ``SET_SOURCE_FILE_PROPERTIES()``.

  ``DIRECTORY <dir>``

    If specified, then the sources for the executable listed in ``SOURCES
    <src0> <src1> ...`` are assumed to be in the relative or absolute
    directory ``<dir>`` instead of the current source directory.  This
    directory path is prepended to each source file name ``<srci>`` unless
    ``<srci>`` is an absolute path.

  ``CATEGORIES <category0> <category1> ...``

    Gives the `Test Test Categories`_ for which this test will be added.
    See `TRIBITS_ADD_TEST()`_ for more details.

  ``HOST <host0> <host1> ...``

    The list of hosts for which to enable the test (see `TRIBITS_ADD_TEST()`_).

  ``XHOST <host0> <host1> ...``

    The list of hosts for which **not** to enable the test (see
    `TRIBITS_ADD_TEST()`_).

  ``HOSTTYPE <hosttype0> <hosttype1> ...``

    The list of host types for which to enable the test (see
    `TRIBITS_ADD_TEST()`_).

  ``XHOSTTYPE <hosttype0> <hosttype1> ...``

    The list of host types for which **not** to enable the test (see
    `TRIBITS_ADD_TEST()`_).

  ``DEPLIBS <lib0> <lib1> ...``

    Specifies extra libraries that will be linked to the executable using
    ``TARGET_LINK_LIBRARY()``.  Note that regular libraries (i.e. not
    ``TESTONLY``) defined in the current SE package or any upstream SE
    packages do **NOT** need to be listed!  TriBITS automatically links non
    ``TESTONLY`` libraries in this package and upstream packages to the
    executable.  The only libraries that should be listed in this argument
    are either ``TESTONLY`` libraries, or other libraries that are built
    external from this CMake project and are not provided through a proper
    `TriBITS TPL`_.  The latter usage of passing in external libraries is
    not recommended.  External libraries should be handled as declared
    `TriBITS TPLs`_.  For a ``TESTONLY`` library, the include directories
    will automatically be added using::

      INCLUDE_DIRECTORIES(${<libi>_INCLUDE_DIRS})

    where ``<libi>_INCLUDE_DIRS`` was set by::

      TRIBITS_ADD_LIBRARY(<libi> ... TESTONLY ...)

    Therefore, to link to a defined ``TESTONLY`` library in any upstream
    enabled package, one just needs to pass in the library name through
    ``DEPLIBS ... <libi> ...`` and that is it!

  ``COMM [serial] [mpi]``

    If specified, selects if the test will be added in serial and/or MPI
    mode.  See the ``COMM`` argument in the script
    `TRIBITS_ADD_TEST()`_ for more details.

  ``LINKER_LANGUAGE (C|CXX|Fortran)``

    If specified, overrides the linker language used by setting the built-in
    CMake target property ``LINKER_LANGUAGE``.  By default, CMake chooses the
    compiler to be used as the linker based on file extensions.  The most
    typical use case for this option is when Fortran-only or C-only sources
    are passed in through ``SOURCES`` but a C++ linker is needed because
    there are upstream C++ libraries.

  ``DEFINES -D<define0> -D<define1> ...``

    Add the listed defines using ``ADD_DEFINITIONS()``.  These should only
    affect the listed sources for the built executable and not other
    compiles in this directory due to the FUNCTION scoping.

  ``INSTALLABLE``

    If passed in, then an install target will be added to install the built
    executable into the ``${CMAKE_INSTALL_PREFIX}/bin/`` directory (see
    `Install Target (TRIBITS_ADD_EXECUTABLE())`_).

.. _Executable and Target Name (TRIBITS_ADD_EXECUTABLE()):

**Executable and Target Name (TRIBITS_ADD_EXECUTABLE())**

By default, the full name of the executable and target name
is::

  <fullExecName> = ${PACKAGE_NAME}_<exeRootName>

If ``ADD_DIR_TO_NAME`` is set, then the directory path relative to the
package base directory (with "/" replaced with "_"), or ``<relDirName>``, is
added to the executable name to form::

  <fullExecName> = ${PACKAGE_NAME}_<relDirName>_<exeRootName>

If the option ``NOEXEPREFIX`` is passed in, then the prefix
``${PACKAGE_NAME}_`` is removed.

The executable suffix ``${${PROJECT_NAME}_CMAKE_EXECUTABLE_SUFFIX}`` will be
added to the actual executable file name if the option ``NOEXESUFFIX`` is
*not* passed in but this suffix is never added to the target name.

The reason that a default prefix is prepended to the executable and target
name is because the primary reason to create an executable is typically to
create a test or an example that is private to the package.  This prefix
helps to namespace the executable and its target so as to avoid name clashes
with targets in other packages.  It also helps to avoid clashes if the
executable gets installed into the install directory (if ``INSTALLABLE`` is
specified).  For general utility executables on Linux/Unix systems,
``NOEXEPREFIX`` and ``NOEXESUFFIX`` should be passed in.  In this case, one
must be careful to pick ``<exeRootName>`` that will be sufficiently globally
unique.  Please use common sense when picking non-namespaced names.

.. _Additional Executable and Source File Properties (TRIBITS_ADD_EXECUTABLE()):

**Additional Executable and Source File Properties (TRIBITS_ADD_EXECUTABLE())**

Once ``ADD_EXECUTABLE(<fullExeName> ... )`` is called and this function
exists, one can set and change properties on the ``<fullExeName>``
executable target using the built-in ``SET_TARGET_PROPERTIES()`` command as
well as properties on any of the source files listed in ``SOURCES`` using
the built-in ``SET_SOURCE_FILE_PROPERTIES()`` command just like in any CMake
project.

.. _Install Target (TRIBITS_ADD_EXECUTABLE()):

**Install Target (TRIBITS_ADD_EXECUTABLE())**

If ``INSTALLABLE`` is passed in, then an install target using the built-in
CMake command ``INSTALL(TARGETS <fullExeName> ...)`` is added to install the
built executable into the ``${CMAKE_INSTALL_PREFIX}/bin/`` directory (actual
install directory path is determined by
``${PROJECT_NAME}_INSTALL_RUNTIME_DIR``, see `Setting the install prefix at
configure time`_) .

TRIBITS_ADD_EXECUTABLE_AND_TEST()
+++++++++++++++++++++++++++++++++

Add an executable and a test (or several tests) all in one shot (just calls
`TRIBITS_ADD_EXECUTABLE()`_ followed by `TRIBITS_ADD_TEST()`_).

Usage::

  TRIBITS_ADD_EXECUTABLE_AND_TEST(
    <exeRootName>  [NOEXEPREFIX]  [NOEXESUFFIX]  [ADD_DIR_TO_NAME]
    SOURCES <src0> <src1> ...
    [NAME <testName> | NAME_POSTFIX <testNamePostfix>]
    [CATEGORIES <category0>  <category1> ...]
    [HOST <host0> <host1> ...]
    [XHOST <xhost0> <xhost1> ...]
    [XHOST_TEST <xhost0> <xhost1> ...]
    [HOSTTYPE <hosttype0> <hosttype1> ...]
    [XHOSTTYPE <xhosttype0> <xhosttype1> ...]
    [XHOSTTYPE_TEST <xhosttype0> <xhosttype1> ...]
    [DIRECTORY <dir>]
    [DEFINES -DS<someDefine>]
    [DEPLIBS <lib0> <lib1> ... ]
    [COMM [serial] [mpi]]
    [ARGS "<arg0> <arg1> ..." "<arg2> <arg3> ..." ...]
    [NUM_MPI_PROCS <numProcs>]
    [LINKER_LANGUAGE (C|CXX|Fortran)]
    [STANDARD_PASS_OUTPUT
      | PASS_REGULAR_EXPRESSION "<regex0>;<regex1>;..."]
    [FAIL_REGULAR_EXPRESSION "<regex0>;<regex1>;..."]
    [WILL_FAIL]
    [ENVIRONMENT <var0>=<value0> <var1>=<value1> ...]
    [INSTALLABLE]
    [TIMEOUT <maxSeconds>]
    )

This function takes a fairly common set of arguments to
`TRIBITS_ADD_EXECUTABLE()`_ and `TRIBITS_ADD_TEST()`_ but not the full set
passed to ``TRIBITS_ADD_TEST()``.  See the documentation for
`TRIBITS_ADD_EXECUTABLE()`_ and `TRIBITS_ADD_TEST()`_ to see which arguments
are accepted by which functions.

Arguments that are specific to this function and not directly passed on to
``TRIBITS_ADD_EXECUTABLE()`` or ``TRIBITS_ADD_TEST()`` include:

  ``XHOST_TEST <xhost0> <xhost1> ...``

    When specified, this disables just running the tests for the named hosts
    ``<xhost0>``, ``<xhost0>`` etc. but still builds the executable for the
    test.  These are just passed in through the ``XHOST`` argument to
    ``TRIBITS_ADD_TEST()``.

  ``XHOSTTYPE_TEST <xhosttype0> <hosttype1> ...``

    When specified, this disables just running the tests for the named host
    types ``<hosttype0>``, ``<hosttype0>``, ..., but still builds the
    executable for the test.  These are just passed in through the
    ``XHOSTTYPE`` argument to ``TRIBITS_ADD_TEST()``.

This is the function to use for simple test executables that you want to run
that either takes no arguments or just a simple set of arguments passed in
through ``ARGS``.  For more flexibility, just use
``TRIBITS_ADD_EXECUTABLE()`` followed by ``TRIBITS_ADD_TEST()``.

TRIBITS_ADD_LIBRARY()
+++++++++++++++++++++

Function used to add a CMake library and target using ``ADD_LIBRARY()``.

Usage::

  TRIBITS_ADD_LIBRARY(
    <libName>
    [HEADERS <h0> <h1> ...]
    [NOINSTALLHEADERS <nih0> <hih1> ...]
    [SOURCES <src0> <src1> ...]
    [DEPLIBS <deplib0> <deplib1> ...]
    [IMPORTEDLIBS <ideplib0> <ideplib1> ...]
    [TESTONLY]
    [NO_INSTALL_LIB_OR_HEADERS]
    [CUDALIBRARY]
    )

*Sections:*

* `Formal Arguments (TRIBITS_ADD_LIBRARY())`_
* `Include Directories (TRIBITS_ADD_LIBRARY())`_
* `Install Targets (TRIBITS_ADD_LIBRARY())`_
* `Additional Library and Source File Properties (TRIBITS_ADD_LIBRARY())`_
* `Miscellaneous Notes (TRIBITS_ADD_LIBRARY())`_

.. _Formal Arguments (TRIBITS_ADD_LIBRARY()):

**Formal Arguments (TRIBITS_ADD_LIBRARY())**

  ``<libName>``

    Required name of the library.  This is the name passed to
    ``ADD_LIBRARY(<libName> ...)``.  The name is *not* prefixed by the
    package name.  CMake will of course add any standard prefix or post-fix
    to the library file name appropriate for the platform and if this is a
    static or shared library build (see documentation for the built-in CMake
    command ``ADD_LIBRARY()``.

  ``HEADERS <h0> <h1> ...``

    List of public header files for using this library.  By default, these
    header files are assumed to be in the current source directory.  They
    can also contain the relative path or absolute path to the files if they
    are not in the current source directory.  This list of headers is passed
    into ``ADD_LIBRARY(...)`` as well (which is not strictly needed but is
    helpful for some build tools, like MS Visual Studio).  By default, these
    headers will be installed (see `Install Targets
    (TRIBITS_ADD_LIBRARY())`_).

  ``NOINSTALLHEADERS <nih0> <hih1> ...``

    List of private header files which are used by this library. These
    headers are not installed and do not needed to be passed in for any
    purpose other than to pass them into ``ADD_LIBRARY()`` as some build
    tools like to have these listed (e.g. MS Visual Studio).

  ``SOURCES <src0> <src1> ...``

    List of source files passed into ``ADD_LIBRARY()`` that are compiled
    into header files and included in the library.  The compiler used to
    compile the files is determined automatically based on the file
    extension (see CMake documentation for ``ADD_LIBRARY()``).

  ``DEPLIBS <deplib0> <deplib1> ...``

    List of dependent libraries that are built in the current SE package
    that this library is dependent on.  These libraries are passed into
    ``TARGET_LINK_LIBRARIES(<libName> ...)`` so that CMake knows about the
    dependency structure of the libraries within the package.  **NOTE:** One
    must **not** list libraries in other upstream `TriBITS SE Packages`_ or
    libraries built externally from this TriBITS CMake project.  The TriBITS
    system automatically handles linking to libraries in upstream TriBITS SE
    packages.  External libraries need to be listed in the ``IMPORTEDLIBS``
    argument instead if they are not already specified automatically using a
    `TriBITS TPL`_.

  ``IMPORTEDLIBS <ideplib0> <ideplib1> ...``

    List of dependent libraries built externally from this TriBITS CMake
    project.  These libraries are passed into
    ``TARGET_LINK_LIBRARIES(<libName> ...)`` so that CMake knows about the
    dependency.  These libraries are added to the
    ``${PACKAGE_NAME}_LIBRARIES`` variable so that downstream SE packages
    will also pick up these libraries and these libraries will show up in
    the generated ``Makefile.export.${PACKAGE_NAME}`` and
    ``${PACKAGE_NAME}Config.cmake`` files (if they are generated).  However,
    note that external libraries are often better handled as `TriBITS
    TPLs`_.  A well constructed TriBITS package and library should never
    have to use this option!

  ``TESTONLY``

    If passed in, then ``<libName>`` will **not** be added to
    ``${PACKAGE_NAME}_LIBRARIES`` and an install target for the library will
    not be added.  In this case, the current include directories will be set
    in the global variable ``<libName>_INCLUDE_DIR`` which will be used in
    `TRIBITS_ADD_EXECUTABLE()`_ when a test-only library is linked in
    through its ``DEPLIBS`` argument.

  ``NO_INSTALL_LIB_OR_HEADERS``

    If specified, then no install targets will be added for the library
    ``<libName>`` or the header files listed in ``HEADERS``.

  ``CUDALIBRARY``

    If specified then ``CUDA_ADD_LIBRARY()`` is used instead of
    ``ADD_LIBRARY()`` where ``CUDA_ADD_LIBRARY()`` is assumed to be defined
    by the standard ``FindCUDA.cmake`` module as processed using the
    standard TriBITS ``FindTPLCUDA.cmake`` file (see `Standard TriBITS
    TPLs`_).  For this option to work, this SE package must have an enabled
    direct or indirect dependency on the TriBITS CUDA TPL or a
    configure-time error may occur about not knowing about
    ``CUDA_ALL_LIBRARY()``.

.. _Include Directories (TRIBITS_ADD_LIBRARY()):

**Include Directories (TRIBITS_ADD_LIBRARY())**

Any base directories for the header files listed in the arguments
``HEADERS`` or ``NOINSTALLHEADERS`` should be passed into the standard CMake
command ``INCLUDE_DIRECTORIES()`` *before* calling this function.  These
include directories will then be added to current packages list of include
directories ``${PACKAGE_NAME}_INCLUDE_DIRS`` which is then exported to
downstream SE packages..

.. _Install Targets (TRIBITS_ADD_LIBRARY()):

**Install Targets (TRIBITS_ADD_LIBRARY())**

By default, an install target for the library is created using
``INSTALL(TARGETS <libName> ...)`` to install into the directory
``${CMAKE_INSTALL_PREFIX}/lib/`` (actual install directory is given by
``${PROJECT}_INSTALL_LIB_DIR``, see `Setting the install prefix at configure
time`_).  However, this install target will not get created if
``${PROJECT_NAME}_INSTALL_LIBRARIES_AND_HEADERS=FALSE`` and
``BUILD_SHARD_LIBS=OFF``.  But when ``BUILD_SHARD_LIBS=ON``, the install
target will get created.  Also, this install target will *not* get created
if ``TESTONLY`` or ``NO_INSTALL_LIB_OR_HEADERS`` are passed in.

By default, an install target for the headers listed in ``HEADERS`` will get
created using ``INSTALL(FILES <h0> <h1> ...)``, but only if ``TESTONLY`` and
``NO_INSTALL_LIB_OR_HEADERS`` are not passed in as well.  These headers get
installed into the flat directory ``${CMAKE_INSTALL_PREFIX}/include/`` (the
actual install directory is given by
``${PROJECT_NAME}_INSTALL_INCLUDE_DIR``, see `Setting the install prefix at
configure time`_).  Note that an install target will *not* get created for
the headers listed in ``NOINSTALLHEADERS``.

.. _Additional Library and Source File Properties (TRIBITS_ADD_LIBRARY()):

**Additional Library and Source File Properties (TRIBITS_ADD_LIBRARY())**

Once ``ADD_LIBRARY(<libName> ... <src0> <src1> ...)`` is called, one can set
and change properties on the ``<libName>`` library target using the built-in
CMake command ``SET_TARGET_PROPERTIES()`` as well as set and change
properties on any of the source files listed in ``SOURCES`` using the
built-in CMake command ``SET_SOURCE_FILE_PROPERTIES()`` just like in any
CMake project.

.. _Miscellaneous Notes (TRIBITS_ADD_LIBRARY()):

**Miscellaneous Notes (TRIBITS_ADD_LIBRARY())**

**WARNING:** Do **NOT** use the built-in CMake command ``ADD_DEFINITIONS()``
to add defines ``-D<someDefine>`` to the compile command line that will
affect any of the header files in the package!  These CMake-added defines
are only set locally in this directory and child directories.  These defines
will **NOT** be set when code in peer directories (e.g. a downstream TriBITS
packages) compiles that may include these header files.  To add defines that
affect header files, please use a configured header file (see
`TRIBITS_CONFIGURE_FILE()`_).

TRIBITS_ADD_OPTION_AND_DEFINE()
+++++++++++++++++++++++++++++++

Add an option and a define variable in one shot.

Usage::

 TRIBITS_ADD_OPTION_AND_DEFINE( <userOptionName>  <macroDefineName>
   "<docStr>"  <defaultValue> )

This macro sets the user cache ``BOOL`` variable ``<userOptionName>`` and if
it is true, then sets the global (internal cache) macro define variable
``<macroDefineName>`` to ``ON``, and otherwise sets it to ``OFF``.  This is
designed to make it easy to add a user-enabled option to a configured header
file and have the define set in one shot.  This would require that the
package's configure file (see `TRIBITS_CONFIGURE_FILE()`_) have the line::

  #cmakedefine <macroDefineName>

TRIBITS_ADD_SHOW_DEPRECATED_WARNINGS_OPTION()
+++++++++++++++++++++++++++++++++++++++++++++

Add the standard option ``${PACKAGE_NAME}_SHOW_DEPRECATED_WARNINGS`` for the
package.

Usage::

  TRIBITS_ADD_SHOW_DEPRECATED_WARNINGS_OPTION()

This macro should be called in the package's <packageDir>/CMakeLists.txt`_
file.  This option is given the default value
``${${PROJECT_NAME}_SHOW_DEPRECATED_WARNINGS}``.  This option is then looked
for in `TRIBITS_CONFIGURE_FILE()`_ to add macros to add deprecated warnings
to deprecated parts of a package.

TRIBITS_ADD_TEST()
++++++++++++++++++

Add a test or a set of tests for a single executable or command using CTest
``ADD_TEST()``.

Usage::

  TRIBITS_ADD_TEST(
    <exeRootName>  [NOEXEPREFIX]  [NOEXESUFFIX]
    [NAME <testName> | NAME_POSTFIX <testNamePostfix>]
    [DIRECTORY <directory>]
    [ADD_DIR_TO_NAME]
    [ARGS "<arg0> <arg1> ..." "<arg2> <arg3> ..." ...
      | POSTFIX_AND_ARGS_0 <postfix0> <arg0> <arg1> ...
        POSTFIX_AND_ARGS_1 ... ]
    [COMM [serial] [mpi]]
    [NUM_MPI_PROCS <numProcs>]
    [CATEGORIES <category0>  <category1> ...]
    [HOST <host0> <host1> ...]
    [XHOST <host0> <host1> ...]
    [HOSTTYPE <hosttype0> <hosttype1> ...]
    [XHOSTTYPE <hosttype0> <hosttype1> ...]
    [STANDARD_PASS_OUTPUT
      | PASS_REGULAR_EXPRESSION "<regex0>;<regex1>;..."]
    [FAIL_REGULAR_EXPRESSION "<regex0>;<regex1>;..."]
    [WILL_FAIL]
    [ENVIRONMENT <var0>=<value0> <var1>=<value1> ...]
    [TIMEOUT <maxSeconds>]
    )

*Sections:*

* `Formal Arguments (TRIBITS_ADD_TEST())`_
* `Determining the Executable or Command to Run (TRIBITS_ADD_TEST())`_
* `Determining the Full Test Name (TRIBITS_ADD_TEST())`_
* `Adding Multiple Tests  (TRIBITS_ADD_TEST())`_
* `Determining Pass/Fail (TRIBITS_ADD_TEST())`_
* `Setting additional test properties (TRIBITS_ADD_TEST())`_
* `Running multiple tests at the same time (TRIBITS_ADD_TEST())`_
* `Debugging and Examining Test Generation (TRIBITS_ADD_TEST())`_
* `Disabling Tests Externally (TRIBITS_ADD_TEST())`_

.. _Formal Arguments (TRIBITS_ADD_TEST()):

**Formal Arguments (TRIBITS_ADD_TEST())**

  ``<exeRootName>``

    The name of the executable or path to the executable to run for the test
    (see `Determining the Executable or Command to Run
    (TRIBITS_ADD_TEST())`_).  This name is also the default root name for
    the test (see `Determining the Full Test Name (TRIBITS_ADD_TEST())`_).

  ``NOEXEPREFIX``

   If specified, then the prefix ``${PACKAGE_NAME}_`` is assumed **not** to
   be prepended to ``<exeRootName>`` (see `Determining the Executable or
   Command to Run (TRIBITS_ADD_TEST())`_).

  ``NOEXESUFFIX``

     If specified, then the postfix
     ``${${PROJECT_NAME}_CMAKE_EXECUTABLE_SUFFIX}`` is assumed **not** to be
     post-pended to ``<exeRootName>`` (see `Determining the Executable or
     Command to Run (TRIBITS_ADD_TEST())`_).

  ``NAME <testRootName>``

    If specified, gives the root name of the test.  If not specified, then
    ``<testRootName>`` is taken to be ``<exeRootName>``.  The actual test
    name passed to ``ADD_TEST()`` will always be prefixed as
    ``${PACKAGE_NAME}_<testRootName>``.  The main purpose of this argument
    is to allow multiple tests to be defined for the same executable.  CTest
    requires all test names to be globally unique in a single project.  See
    `Determining the Full Test Name (TRIBITS_ADD_TEST())`_.
 
  ``NAME_POSTFIX <testNamePostfix>``

    If specified, gives a postfix that will be added to the standard test
    name based on ``<exeRootName>`` (appended as ``_<NAME_POSTFIX>``).  If
    the ``NAME <testRootName>`` argument is given, this argument is ignored.
    See `Determining the Full Test Name (TRIBITS_ADD_TEST())`_.
 
  ``DIRECTORY <dir>``

    If specified, then the executable is assumed to be in the directory
    given by ``<dir>``.  The directory ``<dir>`` can either be a relative or
    absolute path.  If not specified, the executable is assumed to be in the
    current binary directory ``${CMAKE_CURRENT_BINARY_DIR}``.  See
    `Determining the Executable or Command to Run (TRIBITS_ADD_TEST())`_.
  
  ``ADD_DIR_TO_NAME``

    If specified, then the directory name that this test resides in will be
    added into the name of the test after the package name is added and
    before the root test name (see `Determining the Full Test Name
    (TRIBITS_ADD_TEST())`_).  The directory name will have the package's
    base directory stripped off so only the unique part of the test
    directory will be used.  All directory separators ``"/"`` will be
    changed into underscores ``"_"``.
 
  ``RUN_SERIAL``

    If specified then no other tests will be allowed to run while this test
    is running. This is useful for devices (like CUDA GPUs) that require
    exclusive access for processes/threads.  This just sets the CTest test
    property ``RUN_SERIAL`` using the built-in CMake function
    ``SET_TESTS_PROPERTIES()``.
 
  ``ARGS "<arg0> <arg1> ..." "<arg2> <arg3> ..." ...``

    If specified, then a set of arguments can be passed in quotes.  If
    multiple groups of arguments are passed in different quoted clusters of
    arguments then a different test will be added for each set of arguments.
    In this way, many different tests can be added for a single executable
    in a single call to this function.  Each of these separate tests will be
    named ``<fullTestName>_xy`` where ``xy`` = ``00``, ``01``, ``02``, and so
    on.  **WARNING:** When defining multiple tests it is preferred to use the
    ``POSTFIX_AND_ARGS_<IDX>`` form instead.  **WARNING:** Multiple
    arguments passed to a single test invocation must be quoted or multiple
    tests taking single arguments will be created instead!  See `Adding
    Multiple Tests (TRIBITS_ADD_TEST())`_ for more details and exmaples.
 
  ``POSTFIX_AND_ARGS_<IDX> <postfix> <arg0> <arg1> ...``

    If specified, gives a sequence of sets of test postfix names and
    arguments lists for different tests (up to ``POSTFIX_AND_ARGS_19``).
    For example, a set of three different tests with argument lists can be
    specified as::
      
      POSTIFX_AND_ARGS_0 postfix0 --arg1 --arg2="dummy"
      POSTIFX_AND_ARGS_1 postfix1  --arg2="fly"
      POSTIFX_AND_ARGS_2 postfix2  --arg2="bags"
 
    This will create three different test cases with the postfix names
    ``postfix0``, ``postfix1``, and ``postfix2``.  The indexes must be
    consecutive starting a ``0`` and going up to (currently) ``19``.  The
    main advantages of using these arguments instead of just ``ARGS`` are
    that one can give a meaningful name to each test case and one can
    specify multiple arguments without having to quote them and one can
    allow long argument lists to span multiple lines.  See `Adding Multiple
    Tests (TRIBITS_ADD_TEST())`_ for more details and exmaples.
 
  ``COMM [serial] [mpi]``

    If specified, determines if the test will be added in serial and/or MPI
    mode.  If the ``COMM`` argument is missing, the test will be added in
    both serial and MPI builds of the code.  That is if ``COMM mpi`` is
    passed in, then the test will **not** be added if
    ``TPL_ENABLE_MPI=OFF``.  Likewise, if ``COMM serial`` is passed in, then
    the test will **not** be added if ``TPL_ENABLE_MPI=ON``.  If ``COMM
    serial mpi`` or ``COMM mpi serial`` is passed in, then the value of
    ``TPL_ENABLE_MPI`` does not determine if the test is added or not.
 
  ``NUM_MPI_PROCS <numProcs>``

    If specified, gives the number of MPI processes used to run the test
    with the MPI exec program ``${MPI_EXEC}``.  If ``<numProcs>`` is greater
    than ``${MPI_EXEC_MAX_NUMPROCS}`` then the test will be excluded.  If
    not specified, then the default number of processes for an MPI build
    (i.e. ``TPL_ENABLE_MPI=ON``) will be ``${MPI_EXEC_DEFAULT_NUMPROCS}``.
    For serial builds (i.e. ``TPL_ENABLE_MPI=OFF``), this argument is
    ignored.  This will also be set as the built-in test property
    ``PROCESSORS`` to tell CTest how many processes this test will use (see
    `Running multiple tests at the same time (TRIBITS_ADD_TEST())`_).

  ``CATEGORIES <category0> <category1> ...``

    If specified, gives the specific categories of the test.  Valid test
    categories include ``BASIC``, ``CONTINUOUS``, ``NIGHTLY``, ``WEEKLY``
    and ``PERFORMANCE``.  If not specified, the default category is
    ``BASIC``.  When the test category does not match
    ``${PROJECT_NAME}_TEST_CATEGORIES``, then the test is **not** added.
    When ``CATEGORIES`` contains ``BASIC`` it will match
    ``${PROJECT_NAME}_TEST_CATEGORIES`` equal to ``CONTINUOUS``,
    ``NIGHTLY``, and ``WEEKLY``.  When ``CATEGORIES`` contains
    ``CONTINUOUS`` it will match ``${PROJECT_NAME}_TEST_CATEGORIES`` equal
    to ``CONTINUOUS``, ``NIGHTLY``, and ``WEEKLY``.  When ``CATEGORIES``
    contains ``NIGHTLY`` it will match ``${PROJECT_NAME}_TEST_CATEGORIES``
    equal to ``NIGHTLY`` and ``WEEKLY``.  When ``CATEGORIES`` contains
    ``PERFORMANCE`` it will match
    ``${PROJECT_NAME}_TEST_CATEGORIES=PERFORMANCE`` only.

  ``HOST <host0> <host1> ...``

    If specified, gives a list of hostnames where the test will be included.
    The current hostname is determined by the built-in CMake command
    ``SITE_NAME(${PROJECT_NAME}_HOSTNAME)``.  On Linux/Unix systems, this is
    typically the value returned by ``uname -n``.  If this list is given,
    the value of ``${${PROJECT_NAME}_HOSTNAME}`` must equal one of the
    listed host names ``<hosti>`` or test will **not** be added.  The value
    of ``${PROJECT_NAME}_HOSTNAME`` gets printed out in the TriBITS cmake
    output under the section ``Probing the environment`` (see `Full
    Processing of TriBITS Project Files`_).
 
  ``XHOST <host0> <host1> ...``

    If specified, gives a list of hostnames (see ``HOST`` argument) on which
    the test will **not** be added.  This check is performed after the check
    for the hostnames in the ``HOST`` list if it should exist.  Therefore,
    this exclusion list overrides the ``HOST`` inclusion list.

  ``HOSTTYPE <hosttype0> <hosttype1> ...``

    If specified, gives the names of the host system type (given by the
    built-in CMake cache variable ``CMAKE_HOST_SYSTEM_NAME`` which is
    printed in the TriBITS cmake configure output in the section ``Probing
    the environment``) for which the test is allowed to be added.  If
    ``HOSTTYPE`` is specified and ``CMAKE_HOST_SYSTEM_NAME`` is not equal to
    one of the values of ``<hosttypei>``, then the test will **not** be
    added.  Typical host system type names include ``Linux``, ``Darwain``,
    ``Windows``, etc.

  ``XHOSTTYPE <hosttype0> <hosttype1> ...``

    If specified, gives the names of the host system type (see the
    ``HOSTTYPE`` argument above) for which **not** to include the test on.
    This check is performed after the check for the host system names in the
    ``HOSTTYPE`` list if it should exist.  Therefore, this exclusion list
    overrides the ``HOSTTYPE`` inclusion list.

  ``STANDARD_PASS_OUTPUT``

    If specified, then the standard test output string ``End Result: TEST
    PASSED`` is grepped in the test stdout for to determine success.  This
    is needed for MPI tests on some platforms since the return value from
    MPI executables is unreliable.  This is set using the built-in CTest
    property ``PASS_REGULAR_EXPRESSION``.

  ``PASS_REGULAR_EXPRESSION "<regex0>;<regex1>;..."``

    If specified, then the test will be assumed to pass only if one of the
    regular expressions ``<regex0>``, ``<regex1>`` etc. match the output
    send to stdout.  Otherwise, the test will fail.  This is set using the
    built-in CTest property ``PASS_REGULAR_EXPRESSION``.  Consult standard
    CMake documentation for full behavior.

  ``FAIL_REGULAR_EXPRESSION "<regex0>;<regex1>;..."``

    If specified, then a test will be assumed to fail if one of the regular
    expressions ``<regex0>``, ``<regex1>`` etc. match the output send to
    stdout.  Otherwise, the test will pass.  This is set using the built-in
    CTest property ``FAIL_REGULAR_EXPRESSION``.  Consult standard CMake
    documentation for full behavior.

  ``WILL_FAIL``

    If passed in, then the pass/fail criteria will be inverted.  This is set
    using the built-in CTest property ``WILL_FAIL``.  Consult standard CMake
    documentation for full behavior.

  ``ENVIRONMENT <var0>=<value0> <var1>=<value1> ...``

    If passed in, the listed environment variables will be set before
    calling the test.  This is set using the built-in CTest property
    ``ENVIRONMENT``.

  ``TIMEOUT <maxSeconds>``

    If passed in, gives maximum number of seconds the test will be allowed
    to run before being timed-out.  This sets the CTest property
    ``TIMEOUT``.  The value ``<maxSeconds>`` will be scaled by the value of
    `${PROJECT_NAME}_SCALE_TEST_TIMEOUT`_.

    **WARNING:** Rather than just increasing the timeout for an expensive
    test, please try to either make the test run faster or relegate the test
    to being run less often (i.e. set ``CATEGORIES NIGHTLY`` or even
    ``WEEKLY`` for extremely expensive tests).  Expensive tests are one of
    the worse forms of technical debt that a project can have!

In the end, this function just calls the built-in CMake commands
``ADD_TEST(${TEST_NAME} ...)`` and ``SET_TESTS_PROPERTIES(${TEST_NAME}
...)`` to set up a executable process for ``ctest`` to run, determine
pass/fail criteria, and set some other test properties.  Therefore, this
wrapper function does not provide any fundamentally new features that are
not already available in the basic usage if CMake/CTest.  However, this
wrapper function takes care of many of the details and boiler-plate CMake
code that it takes to add such a test (or tests) and enforces consistency
across a large project for how tests are defined, run, and named (to avoid
test name clashes).

If more flexibility or control is needed when defining tests, then the
function `TRIBITS_ADD_ADVANCED_TEST()`_ should be used instead.

In the following subsections, more details on how tests are defined and run
is given.

.. _Determining the Executable or Command to Run (TRIBITS_ADD_TEST()):

**Determining the Executable or Command to Run (TRIBITS_ADD_TEST())**

This function is primarily designed to make it easy to run tests for
executables built using the function `TRIBITS_ADD_EXECUTABLE()`_.  To set up
tests to run arbitrary executables, see below.

By default, the executable to run is determined by first getting the
executable name which by default is assumed to be::

 <fullExeName> =
   ${PACKAGE_NAME}_<exeRootName>${${PROJECT_NAME}_CMAKE_EXECUTABLE_SUFFIX}

which is (by no coincidence) identical to how it is selected in
`TRIBITS_ADD_EXECUTABLE()`_.  This name can be altered by passing in
``NOEXEPREFIX``, ``NOEXESUFFIX``, and ``ADD_DIR_TO_NAME`` as described in
`Executable and Target Name (TRIBITS_ADD_EXECUTABLE())`_.

By default, this executable is assumed to be in the current CMake binary
directory ``${CMAKE_CURRENT_BINARY_DIR}`` but the directory location can be
changed using the ``DIRECTORY <dir>`` argument.  

If an arbitrary executable is to be run (i.e. not build inside of the
project), then pass in ``NOEXEPREFIX`` and ``NOEXESUFFIX`` and set
``<exeRootName>`` to the relative or absolute path of the executable to be
run.  If ``<exeRootName>`` is not an absolute path, then
``${CMAKE_CURRENT_BINARY_DIR}/<exeRootName>`` is set as the executable to
run in this case.

Whatever executable path is specified using this logic, if the executable is
not found, then when ``ctest`` goes to run the test, it will mark it as
``NOT RUN``.

.. _Determining the Full Test Name (TRIBITS_ADD_TEST()):

**Determining the Full Test Name (TRIBITS_ADD_TEST())**

By default, the base test name is selected to be::

  <fullTestName> = ${PACKAGE_NAME}_<exeRootName>

If ``NAME <testRootName>`` is passed in, then ``<testRootName>`` is used
instead of ``<exeRootName>`` above.

If ``NAME_POSTFIX <testNamePostfix>`` is passed in, then the base test name
is selected to be::

  <fullTestName> = ${PACKAGE_NAME}_<exeRootName>_<testNamePostfix>

If ``ADD_DIR_TO_NAME`` is passed in, then the directory name relative to the
package base directory is added to the name as well to help disambiguate the
test name (see the above).

Let the test name determined as described above be ``<fullTestName>``.  If
no arguments or only a single set of arguments are passed in through
``ARGS``, then this is the test name actually passed in to ``ADD_TEST()``.
If multiple tests are defined, then this name becomes the base test name for
each of the tests (see `Adding Multiple Tests (TRIBITS_ADD_TEST())`_).

Finally, for any test that gets defined, if MPI is enabled
(i.e. ``TPL_ENABLE_MPI=ON``), then the terminal suffix
``_MPI_${NUM_MPI_PROCS}`` will be added to the end of the test name (even
for multiple tests).  No such prefix is added for the serial case
(i.e. ``TPL_ENABLE_MPI=OFF``).

.. _Adding Multiple Tests  (TRIBITS_ADD_TEST()):

**Adding Multiple Tests  (TRIBITS_ADD_TEST())**

Using this function, one can add executable arguments and can even add
multiple tests in one of two ways.  One can either pass in one or more
**quoted** clusters of arguments using::

  ARGS "<arg0> <arg1> ..." "<arg2> <arg3> ..." ...

or can pass in an explicit test name postfix and arguments with::

  POSTFIX_AND_ARGS_0 <postfix0> <arg0> <arg1> ...
  POSTFIX_AND_ARGS_1 <postfix1> <arg2> ...
  ...

If only one short set of arguments needs to be passed in, then passing::

  ARGS "<arg0> <arg1>"

may be preferable since it will not add any postfix name to the test.  To
add more than one test case using ``ARGS``, one will use more than one
quoted set of arugments such as with::

  ARGS "<arg0> <arg1>" "<arg2> <arg2>"

which creates 2 tests with the names ``<fullTestName>_00`` passing
arguments ``"<arg0> <arg1>"`` and ``<fullTestName>_01`` passing arguments
``"<arg2> <arg3>"``.  However, when passing multiple sets of arguments it is
preferable to **not** use ``ARGS`` but instead use::

  POSTFIX_AND_ARGS_0 test_a <arg0> <arg1>
  POSTFIX_AND_ARGS_1 test_b <arg2> <arg2>

which also creates the same 2 tests but now with the improved names
``<fullTestName>_test_a`` passing arguments ``"<arg0> <arg1>"`` and
``<fullTestName>_test_b`` passing arguments ``"<arg2> <arg3>"``.  In this way,
the individual tests can be given more understandable names.

The other advantage of the ``POSTFIX_AND_ARGS_<IDX>`` form is that the
arugments ``<arg0>``, ``<arg1>``, ... do not need to be quoted and can
therefore be extended over multiple lines like::

  POSTFIX_AND_ARGS_0 long_args --this-is-the-first-long-arg=very
    --this-is-the-second-long-arg=verylong

If one does not use quotes when using ``ARGS`` one will actually get more
than one test.  For example, if one passes in::

  ARGS --this-is-the-first-long-arg=very
    --this-is-the-second-long-arg=verylong

one actually gets two tests, not one test.  This is a common mistake that
people make when using the ``ARGS`` form of passing arguments.  This can't
be fixed or it will break backward compatibility.  If this could be designed
fresh, the ``ARGS`` argument would only create a single test and the
arguments would not be quoted.

.. _Determining Pass/Fail (TRIBITS_ADD_TEST()):

**Determining Pass/Fail (TRIBITS_ADD_TEST())**

The only means to determine pass/fail is to use the built-in CTest
properties ``PASS_REGULAR_EXPRESSION`` and ``FAIL_REGULAR_EXPRESSION`` which
can only grep the test's STDOUT/STDERR or to check for a 0 return value (or
invert these using ``WILL_FAIL``).  For simple tests, that is enough.
However, for more complex executables, one may need to examine one or more
output files to determine pass/fail.  Raw CMake/CTest cannot do this.  In
this case, one should use `TRIBITS_ADD_ADVANCED_TEST()`_ instead to add the
test.

.. _Setting additional test properties (TRIBITS_ADD_TEST()):

**Setting additional test properties (TRIBITS_ADD_TEST())**

After this function returns, any tests that get added using ``ADD_TEST()``
can have additional properties set and changed using
``SET_TESTS_PROPERTIES()``.  Therefore, any tests properties that are not
directly supported and passed through this wrapper function can be set in
the outer ``CMakeLists.txt`` file after the call to ``TRIBITS_ADD_TEST()``.

ToDo: Describe how to use new variable ``ADDED_TESTS_OUT`` to get the list
of tests actually added (if they are added) in order to make it easy to set
additional test properties.

.. _Running multiple tests at the same time (TRIBITS_ADD_TEST()):

**Running multiple tests at the same time (TRIBITS_ADD_TEST())**

By default, CTest will run many tests defined with ``ADD_TEST()`` at same
time as it can according to its parallel level (e.g. ``'test -j<N>'`` or the
CTest property ``CTEST_PARALLEL_LEVEL``).  For example, when raw ``'ctest
-j10'`` is run, CTest will run multiple tests at the same time to try to
make usage of 10 processes.  If all of the defined tests only used one
process (which is assumed by default except for MPI tests), then CTest will
run 10 tests at the same time and will launch new tests as running tests
finish.  One can also define tests using ``ADD_TEST()`` that use more than
one process such as for MPI tests.  When passing in ``NUM_MPI_PROCS
<numProcs>`` (see above), this TriBITS function will set the built-in CTest
property ``PROCESSORS`` to ``<numProcs>`` using::

  SET_TESTS_PROPERTIES(<fullTestName> PROPERTIES PROCESSORS <numProcs>)

This tells CTest that the defined test uses ``<numProcs>`` processes and
CTest will use that information to not exceed the requested parallel level.
For example, if several ``NUM_MPI_PROCS 3`` tests are defined and CTest is
run with ``'ctest -j12'``, then CTest would schedule and run 4 of these
tests at a time (to make use of 12 processes), starting new ones as running
tests finish, until all of the tests have been run.

When the number of processes a test uses does not cleanly divide into the
requested CTest parallel level, it is not clear how CTest schedules the
tests (hard to find documentation on this but one could always inspect the
CTest source code to find out for sure).  However, one boundary case that is
well observed is that CTest will run all defined tests regardless of the
size of the ``PROCESSORS`` property or the value of
``CTEST_PARALLEL_LEVEL``.  For example, if there are tests where
``PROCESSORS`` is set to 20 but ```ctest -j10'`` is run, then CTest will
still run those tests (using 20 processes) one at a time but will not
schedule any other tests while the parallel level is exceeded.

For single-thread MPI tests, the behavior built into TriBITS does exactly
the right thing.  Defining the test with ``NUM_MPI_PROCS <numProcs>`` will
call ``${MPI_EXEC}`` with ``<numProcs>`` and it will set the CTest property
``PROCESSORS`` to ``<numProcs>``.  However, if the MPI processes use more
than one thread, then CTest could easily oversubscribe the machine.  For
example, consider the case where one is on a machine that only has 16 cores
and one defines MPI tests with ``NUM_MPI_PROCS 4`` but each MPI process
launches 6 threads.  In this case, running these tests with ``'ctest -j8'``,
CTest would schedule 2 of these 4-process tests to run at a time but would
in actuality be using ``2*4*6 = 48`` cores and would overload 32 core
machine.  The other case that is not automatically handled by TriBITS is
when a test script (not MPI) launches multiple processes simultaneously
internally.

Therefore, in cases where the executable or script uses multiple processes,
then one must manually override the ``PROCESSORS`` property.  To do, this
after the ``TRIBITS_ADD_TEST()`` (or `TRIBITS_ADD_ADVANCED_TEST()`_)
function returns, one can reset the ``PROCESSORS`` property` with::

  SET_TESTS_PROPERTIES(<fullTestName> PROPERTIES PROCESSORS <fullNumProces>)

For example, if one runs an MPI program that uses 4 processes and 6 threads
per process, one would call::

  TRIBITS_ADD_TEST(myProg ... NUM_MPI_PROCS 4 ...)
  SET_TESTS_PROPERTIES(${PACKAGE_NAME}_myProg PROPERTIES PROCESSORS 12)

ToDo: Update above example to use loop over ``ADDED_TESTS_OUT``.

.. _Debugging and Examining Test Generation (TRIBITS_ADD_TEST()):

**Debugging and Examining Test Generation (TRIBITS_ADD_TEST())**

In order to see what tests are getting added and to debug some issues in
test creation, one can set the cache variable
``${PROJECT_NAME}_VERBOSE_CONFIGURE=ON``.  This will result in the printout
of some information about the test getting added or not.

Also, CMake writes a file ``CTestTestfile.cmake`` in the current binary
directory which contains all of the added tests and test properties that are
set.  This is the file that is read by ``ctest`` when it runs to determine
what tests to run, determine pass/fail and adjust other behavior using test
properties.  In this file, one can see the exact ``ADD_TEST()`` and
``SET_TESTS_PROPERTIES()`` commands.  The is the ultimate way to debug
exactly what tests are getting added by this function (or if the test is
even being added at all).

.. _Disabling Tests Externally (TRIBITS_ADD_TEST()):

**Disabling Tests Externally (TRIBITS_ADD_TEST())**

The test can be disabled externally by setting the CMake cache variable
``<fullTestName>_DISABLE=TRUE``.  This allows tests to be disabled on a
case-by-case basis by the user (for whatever reason).  Here,
``<fullTestName>`` must be the *exact* name that shows up in 'ctest -N' when
running the test.  If multiple tests are added in this function through
multiple argument sets to ``ARGS`` or through multiple
``POSTFIX_AND_ARGS_<IDX>`` arguments, then ``<fullTestName>_DISABLE=TRUE``
must be set for each test individually.  When a test is disabled in this
way, TriBITS will always print a warning to the ``cmake`` stdout at
configure time warning that the test is being disabled.

TRIBITS_ADD_TEST_DIRECTORIES()
++++++++++++++++++++++++++++++

Macro called to add a set of test directories for an SE package.

Usage::

   TRIBITS_ADD_TEST_DIRECTORIES(<dir1> <dir2> ...)

This macro only needs to be called from the top most ``CMakeLists.txt`` file
for which all subdirectories are all "tests".

This macro can be called several times within a package and it will have the
right effect.

Currently, all this macro does macro is to call ``ADD_SUBDIRECTORY(<diri>)``
if ``${PACKAGE_NAME}_ENABLE_TESTS`` or
``${PARENT_PACKAGE_NAME}_ENABLE_TESTS`` are ``TRUE``. However, this macro
may be extended in the future in order to modify behavior related to adding
tests and examples in a uniform way.

TRIBITS_ALLOW_MISSING_EXTERNAL_PACKAGES()
+++++++++++++++++++++++++++++++++++++++++

Allow listed packages to be missing.  This macro is typically called in a
Package's Dependencies.cmake file.

Usage::

  TRIBITS_ALLOW_MISSING_EXTERNAL_PACKAGES(<pkg0> <plg1> ...)

If the missing upstream SE package ``<pkgi>`` is optional, then the effect
will be to simply ignore the missing package and remove it from the
dependency list for downstream SE packages that have an optional dependency
on the missing upstream SE package.  However, all downstream SE packages
that have a required dependency on the missing upstream SE package
``<pkgi>`` will be hard disabled,
i.e. ``${PROJECT_NAME}_ENABLE_{CURRENT_PACKAGE}=OFF``.

This function is typically used for marking packages in external TriBITS
repos where the repos might be missing.  This allows the downstream repos
and packages to still be enabled (assuming they don't have required
dependencies on the missing packages) when one or more upstream repos are
missing.

Using this function effectively turns off error checking for misspelled
package names so it is important to only use it when it absolutely is
needed.  The typical place to call this macro is in the
`<packageDir>/cmake/Dependencies.cmake`_ files for the packages who list
dependencies on the possibility missing upstream SE package(s).  Therefore,
if a given package is not defined, the ``Dependencies.cmake`` file that
calls this macro will not be processed and the error checking for the listed
packages will not be turned off.  Otherwise, this macro can also be called
from any file processed at the top-level scope *before* all of the
``<packageDir>/cmake/Dependencies.cmake`` files are processed (see `Reduced
Package Dependency Processing`_).  For tweaking at the project level, likely
the best place to call this macro is in the file
`<projectDir>/cmake/ProjectDependenciesSetup.cmake`_.  In this way, it will
not turn off error checking in other projects where the given packages may
always be required and therefore one does not want to turn off error
checking for mispelled package names.

NOTE: Currently, this macro just sets the non-cache local variables
``<pkgi>__ALLOW_MISSING_EXTERNAL_PACKAGE=TRUE``.  Therefore this macro must
be called from the top-level CMake project scope for it to have an effect.

TRIBITS_CONFIGURE_FILE()
++++++++++++++++++++++++

Macro that configures the package's main configured header file (typically
called ``${PACKAGE_NAME}_config.h`` but any name can be used).

Usage::

  TRIBITS_CONFIGURE_FILE(<packageConfigFile>)

This function requires the file::

   ${PACKAGE_SOURCE_DIR}/cmake/<packageConfigFile>.in

exists and it creates the file::

  ${CMAKE_CURRENT_BINARY_DIR}/<packageConfigFile>

by calling the built-in ``CONFIGURE_FILE()`` command::

  CONFIGURE_FILE(
    ${PACKAGE_SOURCE_DIR}/cmake/<packageConfigFile>.in
    ${CMAKE_CURRENT_BINARY_DIR}/<packageConfigFile>
    )

which does basic substitution of CMake variables (see documentation for
built-in CMake `CONFIGURE_FILE()`_ command for rules on how it performs
substitutions).  This command is typically used to configure the package's
main `<packageDir>/cmake/<packageName>_config.h.in`_ file.

In addition to just calling ``CONFIGURE_FILE()``, this function also aids in
creating configured header files adding macros for deprecating code as
described below.

**Deprecated Code Macros**

If ``${PARENT_PACKAGE_NAME}_SHOW_DEPRECATED_WARNINGS`` is ``TRUE`` (see
`TRIBITS_ADD_SHOW_DEPRECATED_WARNINGS_OPTION()`_), then the local CMake
variable ``${PARENT_PACKAGE_NAME_UC}_DEPRECATED_DECLARATIONS`` is set which
adds a define ``<PARENT_PACKAGE_NAME_UC>_DEPRECATED`` (where
``<PARENT_PACKAGE_NAME_UC>`` is the package name in all upper-case letters)
which adds a compiler-specific deprecated warning for an entity.  To take
advantage of this, just add the line::

  @<PARENT_PACKAGE_NAME_UC>_DEPRECATED_DECLARATIONS@

to the ``<packageConfigFile>.in`` file and it will be expanded at configure
time.

Then C/C++ code can use this macro to deprecate functions, variables,
classes, etc., for example, using::

  <PARENT_PACKAGE_NAME_UC>_DEPRECATED class SomeDepreatedClass { ... }.

If the particular compiler does not support deprecated warnings, then this
macro is defined to be empty.  See `Regulated Backward Compatibility and
Deprecated Code`_ for more details.

TRIBITS_COPY_FILES_TO_BINARY_DIR()
++++++++++++++++++++++++++++++++++

Function that copies a list of files from a source directory to a
destination directory at configure time, typically so that it can be used in
one or more tests.

Usage::

  TRIBITS_COPY_FILES_TO_BINARY_DIR(
    <targetName>
    [SOURCE_FILES <file1> <file2> ...]
    [SOURCE_DIR <sourceDir>]
    [DEST_FILES <dfile1> <dfile2> ...]
    [DEST_DIR <destDir>]
    [TARGETDEPS <targDep1> <targDep2> ...]
    [EXEDEPS <exeDep1> <exeDep2> ...]
    [NOEXEPREFIX]
    [CATEGORIES <category1>  <category2> ...]
    )

This sets up all of the custom CMake commands and targets to ensure that the
files in the destination directory are always up to date just by building
the ``ALL`` target.

This function has a few valid calling modes:

**1) Source files and destination files have the same name**::

  TRIBITS_COPY_FILES_TO_BINARY_DIR(
    <targetName>
    SOURCE_FILES <file1> <file2> ...
    [SOURCE_DIR <sourceDir>]
    [DEST_DIR <destDir>]
    [TARGETDEPS <targDep1> <targDep2> ...]
    [EXEDEPS <exeDep1> <exeDep2> ...]
    [NOEXEPREFIX]
    [CATEGORIES <category1>  <category2> ...]
    )

In this case, the names of the source files and the destination files
are the same but just live in different directories.

**2) Source files have a prefix different from the destination files**::

  TRIBITS_COPY_FILES_TO_BINARY_DIR(
    <targetName>
    DEST_FILES <file1> <file2> ...
    SOURCE_PREFIX <srcPrefix>
    [SOURCE_DIR <sourceDir>]
    [DEST_DIR <destDir>]
    [EXEDEPS <exeDep1> <exeDep2> ...]
    [NOEXEPREFIX]
    [CATEGORIES <category1>  <category2> ...]
    )

In this case, the source files have the same basic name as the destination
files except they have the prefix ``<srcPrefix>`` prepended to the name.

**3) Source files and destination files have completely different names**::

  TRIBITS_COPY_FILES_TO_BINARY_DIR(
    <targetName>
    SOURCE_FILES <sfile1> <sfile2> ...
    [SOURCE_DIR <sourceDir>]
    DEST_FILES <dfile1> <dfile2> ...
    [DEST_DIR <destDir>]
    [EXEDEPS <exeDep1> <exeDep2> ...]
    [NOEXEPREFIX]
    [CATEGORIES <category1>  <category2> ...]
    )

In this case, the source files and destination files have completely
different prefixes.

The individual arguments are:

  ``SOURCE_FILES <file1> <file2> ...``

    Listing of the source files relative to the source directory given by
    the argument ``SOURCE_DIR <sourceDir>``.  If omitted, this list will be
    the same as ``DEST_FILES`` with the argument ``SOURCE_PREFIX
    <srcPrefix>`` appended.

  ``SOURCE_DIR <sourceDir>``

    Optional argument that gives the (absolute) base directory for all of
    the source files.  If omitted, this takes the default value of
    ``${CMAKE_CURRENT_SOURCE_DIR}``.

  ``DEST_FILES <file1> <file2> ...``

    Listing of the destination files relative to the destination directory
    given by the argument ``DEST_DIR <destDir>``. If omitted, this list will
    be the same as given by the ``SOURCE_FILES`` list.

  ``DEST_DIR <destDir>``

    Optional argument that gives the (absolute) base directory for all of
    the destination files.  If omitted, this takes the default value of
    ``${CMAKE_CURRENT_BINARY_DIR}``

  ``TARGETDEPS <targDep1> <targDep2> ...``

    Listing of general CMake targets that these files will be added as
    dependencies to.  This results in the copies to be performed when any of
    the targets ``<targDepi>`` are built.

  ``EXEDEPS <exeDep1> <exeDep2> ...``

    Listing of executable targets that these files will be added as
    dependencies to.  By default, the prefix ``${PACKAGE_NAME}_`` will is
    appended to the names of the targets.  This ensures that if the
    executable target is built that these files will also be copied as well.

  ``NOEXEPREFIX``

    Option that determines if the prefix ``${PACKAGE_NAME}_`` will be
    appended to the arguments in the ``EXEDEPS`` list.

TRIBITS_CTEST_DRIVER()
++++++++++++++++++++++

Platform-independent package-by-package CTest/CDash driver (run by ``ctest``
**NOT** ``cmake``).

Usage::

  TRIBITS_CTEST_DRIVER()

This driver code that is platform independent.  This script drives the
testing process by doing a version control (VC) source update on all of the
VC repos and then configuring and building the top-level TriBITS packages
one at a time, in order.  This function gets called from inside of a
platform and build-specific ``ctest -S`` driver script.

To understand this script, one must understand that it gets run in several
different modes:

**Mode 1**: Run where there are already existing source and binary
directories (``CTEST_DASHBOARD_ROOT`` is set empty before call).  This is
for when the ctest driver script is run on an existing source and binary
tree.  In this case, there is one project source tree and
``CTEST_SOURCE_DIRECTORY`` and ``CTEST_BINARY_DIRECTORY`` must be set by the
user before calling this function.  This is used to test a local build and
post to CDash.

**Mode 2**: A new binary directory is created and new sources are cloned (or
updated) in a driver directory (``CTEST_DASHBOARD_ROOT`` is set before
call).  In this case, there are always two (partial) project source tree's,
i) a "driver" skeleton source tree (typically embedded with TriBITS
directory) that bootstraps the testing process, and ii) a true full "source"
that is (optionally) cloned and/or updated.

There are a few different directory locations are significant for this
script:

  ``TRIBITS_PROJECT_ROOT``

    The root directory to an existing source tree where the project's
    `<projectDir>/ProjectName.cmake`_ (defining ``PROJECT_NAME`` variable)
    and ``Version.cmake`` file's can be found.

  ``${PROJECT_NAME}_TRIBITS_DIR``

    The base directory for the TriBITS system's various CMake modules,
    python scripts, and other files.  By default this is assumed to be in
    the source tree under ``${TRIBITS_PROJECT_ROOT}`` (see below) but it can
    be overridden to point to any location.

  ``CTEST_DASHBOARD_ROOT``

    If set, this is the base directory where this script runs that clones
    the sources for the project.  If this directory does not exist, it will
    be created.  If empty, then has no effect on the script.

  ``CTEST_SOURCE_DIRECTORY``

    Determines the location of the sources that are used to define packages,
    dependencies and configure and build the software.  This is a variable
    that CTest directly reads and must therefore be set. This is used to set
    `PROJECT_SOURCE_DIR`_ which is used by the TriBITS system.  If
    ``CTEST_DASHBOARD_ROOT`` is set, then this is hard-coded internally to
    ``${CTEST_DASHBOARD_ROOT}/${CTEST_SOURCE_NAME}``.

  ``CTEST_BINARY_DIRECTORY``

    Determines the location of the binary tree where output from CMake/CTest
    is put.  This is used to set to `PROJECT_BINARY_DIR`_ which is used by
    the TriBITS system.  If ``CTEST_DASHBOARD_ROOT`` is set, then this is
    hard-coded internally to ``${CTEST_DASHBOARD_ROOT}/BUILD``.

ToDo: Document input variables that have defaults, to be set before, and can
be overridden from the env.

ToDo: Finish Documentation!

TRIBITS_DETERMINE_IF_CURRENT_PACKAGE_NEEDS_REBUILT()
++++++++++++++++++++++++++++++++++++++++++++++++++++

Determine at configure time if any of the upstream dependencies for a
package require the current package to be rebuilt.

Usage::

  TRIBITS_DETERMINE_IF_CURRENT_PACKAGE_NEEDS_REBUILT(
    [SHOW_MOST_RECENT_FILES]
    [SHOW_OVERALL_MOST_RECENT_FILES]
    CURRENT_PACKAGE_OUT_OF_DATE_OUT <currentPackageOutOfDate>
    )

**Arguments:**

  ``SHOW_MOST_RECENT_FILES``

    If specified, then the most recently modified file for each individual
    base source and binary directory searched will be will be printed the
    STDOUT.  Setting this implies ``SHOW_OVERALL_MOST_RECENT_FILE``.

  ``SHOW_OVERALL_MOST_RECENT_FILE``

    If specified, then only the most recent modified file over all of the
    individual directories for each category (i.e. one for upstream SE
    package source dirs, one for upstream SE package binary dirs, one for
    the package's source dir, and one for the package's own binary dir) is
    printed to STDOUT.

  ``CURRENT_PACKAGE_OUT_OF_DATE_OUT <currentPackageOutOfDate>``

    On output, the local variable ``<currentPackageOutOfDate>`` will be set
    to ``TRUE`` if any of the upstream most modified files are more recent
    than the most modified file in the package's binary directory.
    Otherwise, this variable is set to ``FALSE``.

**Description:**

This function is designed to help take an externally configured and built
piece of software (that generates libraries) and wrap it as a TriBITS
package or subpackage.  This function uses the lower-level functions:

* `TRIBITS_FIND_MOST_RECENT_SOURCE_FILE_TIMESTAMP()`_ 
* `TRIBITS_FIND_MOST_RECENT_BINARY_FILE_TIMESTAMP()`_

to determine the most recent modified files in the upstream TriBITS SE
packages' source and binary directories as well as the most recent source
file for the current package.  It then compares these timestamps to the most
recent binary file timestamp in this package's binary directory.  If any of
these three files are more recent than this package's most recent binary
file, then the output variable ``<currentPackageOutOfDate>`` is set to
``TRUE``.  Otherwise, it is set to ``FALSE``. 

See the demonstration of the usage of this function in the ``WrapExternal``
package in `TribitsExampleProject`_.

TRIBITS_DISABLE_PACKAGE_ON_PLATFORMS()
++++++++++++++++++++++++++++++++++++++

Disable a package automatically for a list of platforms.

Usage::

  TRIBITS_DISABLE_PACKAGE_ON_PLATFORMS( <packageName>
    <hosttype0> <hosttype1> ...)

If any of the host-type arguments ``<hosttypei>`` matches the
``${PROJECT_NAME}_HOSTTYPE`` variable for the current platform, then package
``<packageName>`` test group classification is changed to ``EX``.  Changing
the package test group classification to ``EX`` results in the package being
disabled by default (see `EX SE packages disabled by default`_).  However,
an explicit enable can still enable the package.

TRIBITS_EXCLUDE_FILES()
+++++++++++++++++++++++

Exclude package files/dirs from the source distribution by appending
``CPACK_SOURCE_IGNORE_FILES``.

Usage::

 TRIBITS_EXCLUDE_FILES(<file0> <file1> ...)

This is called in the package's top-level `<packageDir>/CMakeLists.txt`_
file and each file or directory name ``<filei>`` is actually interpreted by
CMake/CPack as a regex that is prefixed by the project's and package's
source directory names so as to not exclude files and directories of the
same name and path from other packages.  If ``<filei>`` is an absolute path
it it not prefixed but is appended to ``CPACK_SOURCE_IGNORE_FILES``
unmodified.

In general, do **NOT** put in excludes for files and directories that are
not under this package's source tree.  If the given package is not enabled,
then this command will never be called! For example, don't put in excludes
for PackageB's files in PackageA's ``CMakeLists.txt`` file because if
PackageB is enabled but PackageA is not, the excludes for PackageB will
never get added to ``CPACK_SOURCE_IGNORE_FILES``.

Also, be careful to note that the ``<filei>`` arguments are actually regexes
and one must be very careful not understand how CPack will use these regexes
to match files that get excluded from the tarball.  For more details, see
`Creating Source Distributions`_.
   
TRIBITS_FIND_MOST_RECENT_BINARY_FILE_TIMESTAMP()
++++++++++++++++++++++++++++++++++++++++++++++++

Find the most modified binary file in a set of base directories and return
its timestamp.

Usage::

  TRIBITS_FIND_MOST_RECENT_BINARY_FILE_TIMESTAMP(
    BINARY_BASE_DIRS <dir0> <dir1> ... 
    [MOST_RECENT_TIMESTAMP_OUT  <mostRecentTimestamp>]
    [MOST_RECENT_FILEPATH_BASE_DIR_OUT <mostRecentFilepathBaseDir>]
    [MOST_RECENT_RELATIVE_FILEPATH_OUT <mostRecentRelativeFilePath>]
    [SHOW_MOST_RECENT_FILES]
    [SHOW_OVERALL_MOST_RECENT_FILE]
    )

This function just calls `TRIBITS_FIND_MOST_RECENT_FILE_TIMESTAMP()`_
passing in a set of basic exclude regexes like ``CMakeFiles/``,
``[.]cmake$``, and ``/Makefile$``, etc.  These types of files usually don't
impact the build of downstream software in CMake projects.

TRIBITS_FIND_MOST_RECENT_FILE_TIMESTAMP()
+++++++++++++++++++++++++++++++++++++++++

Find the most modified file in a set of base directories and return its
timestamp.

Usage::

  TRIBITS_FIND_MOST_RECENT_FILE_TIMESTAMP(
    BASE_DIRS <dir0> <dir1> ... 
    [EXCLUDE_REGEXES "<re0>" "<re1>" ... 
    [SHOW_MOST_RECENT_FILES]
    [SHOW_OVERALL_MOST_RECENT_FILE]
    [MOST_RECENT_TIMESTAMP_OUT  <mostRecentTimestamp>]
    [MOST_RECENT_FILEPATH_BASE_DIR_OUT <mostRecentFilepathBaseDir>]
    [MOST_RECENT_RELATIVE_FILEPATH_OUT <mostRecentRelativeFilePath>]
    )

**Arguments:**

  ``BASE_DIRS <dir0> <dir1> ...``

    Gives the absolute base directory paths that will be searched for the
    most recently modified files, as described above.

  ``EXCLUDE_REGEXES "<re0>" "<re1>" ...``

    Gives the regular expressions that are used to exclude files from
    consideration.  Each "<rei>" regex is used with a `grep -v "<rei>"`
    filter to exclude files before sorting by time stamp.

  ``SHOW_MOST_RECENT_FILES``

    If specified, then the most recently modified file for each individual
    directory ``<dir0>``, ``<dir1``, ... will be printed the STDOUT.
    Setting this implies ``SHOW_OVERALL_MOST_RECENT_FILE``.

  ``SHOW_OVERALL_MOST_RECENT_FILE``

    If specified, then only the most recent modified file over all of the
    individual directories is printed to STDOUT.

  ``MOST_RECENT_TIMESTAMP_OUT <mostRecentTimestamp>``

     On output, the variable `<mostRecentTimestamp>` is set that gives the
     timestamp of the most recently modified file over all the directories.
     This number is given as the number of seconds since Jan. 1, 1970, 00:00
     GMT.

  ``MOST_RECENT_FILEPATH_BASE_DIR_OUT <mostRecentFilepathBaseDir>``

    On output, the variable `<mostRecentFilepathBaseDir>` gives absolute base
    directory of the file with the most recent timestamp over all
    directories.

  ``MOST_RECENT_RELATIVE_FILEPATH_OUT <mostRecentRelativeFilePath>``

    On output, the variable `<mostRecentFilepathBaseDir>` gives the file
    name with relative path to the file with the most recent timestamp over
    all directories.

**Description:**

This function uses the Linux/Unix command::
    
    $ find . -type f -printf '%T@ %p\n'
        | grep -v "<re0>" | grep -v "<re1>" | ... \
        | sort -n | tail -1

to return the most recent file in each listed directory <dir0>, <dir1>, etc.
It then determines the most recently modified file over all of the
directories and prints and returns in the variables `<mostRecentTimestamp>`,
`<mostRecentFilepathBaseDir>`, and `<mostRecentRelativeFilePath>`.

TRIBITS_FIND_MOST_RECENT_SOURCE_FILE_TIMESTAMP()
++++++++++++++++++++++++++++++++++++++++++++++++

Find the most modified source file in a set of base directories and return
its timestamp.

Usage::

  TRIBITS_FIND_MOST_RECENT_SOURCE_FILE_TIMESTAMP(
    SOURCE_BASE_DIRS <dir0> <dir1> ... 
    [SHOW_MOST_RECENT_FILES]
    [SHOW_OVERALL_MOST_RECENT_FILE]
    [MOST_RECENT_TIMESTAMP_OUT  <mostRecentTimestamp>]
    [MOST_RECENT_FILEPATH_BASE_DIR_OUT <mostRecentFilepathBaseDir>]
    [MOST_RECENT_RELATIVE_FILEPATH_OUT <mostRecentRelativeFilePath>]
    )

This function just calls `TRIBITS_FIND_MOST_RECENT_FILE_TIMESTAMP()`_
passing in a set of basic exclude regexes like ``[.]git/``, ``[.]svn/``,
etc.  These types of version control files can not possibly directly impact
the source code.

TRIBITS_INCLUDE_DIRECTORIES()
+++++++++++++++++++++++++++++

This function is to override the standard behavior of the built-in CMake
``INCLUDE_DIRECTORIES()`` command.

Usage::

  TRIBITS_INCLUDE_DIRECTORIES(
    [REQUIRED_DURING_INSTALLATION_TESTING] <dir0> <dir1> ...
    )

If specified, ``REQUIRED_DURING_INSTALLATION_TESTING`` can appear anywhere
in the argument list.

This function allows overriding the default behavior of
``INCLUDE_DIRECTORIES()`` for installation testing, to ensure that include
directories will not be inadvertently added to the build lines for tests
during installation testing (see `Installation and Backward Compatibility
Testing`_). Normally we want the include directories to be handled as cmake
usually does.  However during TriBITS installation testing we do not want
most of the include directories to be used as the majority of the files
should come from the installation we are building against.  There is an
exception to this and that is when there are test only headers that are
needed.  For that case ``REQUIRED_DURING_INSTALLATION_TESTING`` must be
passed in to ensure the include paths are added for installation testing.

TRIBITS_PACKAGE()
+++++++++++++++++

Macro called at the very beginning of a package's top-level
`<packageDir>/CMakeLists.txt`_ file.

Usage::

  TRIBITS_PACKAGE(
    <packageName>
    [ENABLE_SHADOWING_WARNINGS]
    [DISABLE_STRONG_WARNINGS]
    [CLEANED]
    [DISABLE_CIRCULAR_REF_DETECTION_FAILURE]
    )

See `TRIBITS_PACKAGE_DECL()`_ for the documentation for the arguments and
`TRIBITS_PACKAGE_DECL()`_ and `TRIBITS_PACKAGE()`_ for a description the
side-effects (and variables set) after calling this macro.

TRIBITS_PACKAGE_DECL()
++++++++++++++++++++++

Macro called at the very beginning of a package's top-level
`<packageDir>/CMakeLists.txt`_ file when a package has subpackages.

Usage::

  TRIBITS_PACKAGE_DECL(
    <packageName>
    [ENABLE_SHADOWING_WARNINGS]
    [DISABLE_STRONG_WARNINGS]
    [CLEANED]
    [DISABLE_CIRCULAR_REF_DETECTION_FAILURE]
    )

The arguments are:

  ``<packageName>``

    Gives the name of the Package, mostly just for checking and
    documentation purposes.  This must match the name of the package
    provided in the `<repoDir>/PackagesList.cmake`_ or an error is issued.

  ``ENABLE_SHADOWING_WARNINGS``

    If specified, then shadowing warnings for the package's sources will be
    turned on for supported platforms/compilers.  The default is for
    shadowing warnings to be turned off.  Note that this can be overridden
    globally by setting the cache variable
    ``${PROJECT_NAME}_ENABLE_SHADOWING_WARNINGS``.

  ``DISABLE_STRONG_WARNINGS``

    If specified, then all strong warnings for the package's sources will be
    turned off, if they are not already turned off by global cache
    variables.  Strong warnings are turned on by default in development
    mode.
 
  ``CLEANED``

    If specified, then warnings will be promoted to errors for compiling the
    package's sources for all defined warnings.
 
  ``DISABLE_CIRCULAR_REF_DETECTION_FAILURE``

    If specified, then the standard grep looking for RCPNode circular
    references in `TRIBITS_ADD_TEST()`_ and `TRIBITS_ADD_ADVANCED_TEST()`_
    that causes tests to fail will be disabled.  Note that if these warnings
    are being produced then it means that the test is leaking memory and
    user like may also be leaking memory.

There are several side-effects of calling this macro:

* The variables ``${PACKAGE_NAME}_LIB_TARGETS`` (lists all of the package's
  targets) and ``${PACKAGE_NAME}_ALL_TARGETS`` (lists all of the package's
  libraries) and are initialized to empty.

* The local variables ``PACKAGE_SOURCE_DIR`` and ``PACKAGE_BINARY_DIR`` are
  set for this package's use in its CMakeLists.txt files.

* Package-specific compiler options are set up in package-scope (i.e., the
  package's subdirs) in ``CMAKE_<LANG>_FLAG``.

* This packages's cmake subdir ``${PACKAGE_SOURCE_DIR}/cmake`` is added to
  ``CMAKE_MODULE_PATH`` locally so that the package's try-compile modules
  can be read in with just a raw ``INCLUDE()`` leaving off the full path and
  the ``*.cmake`` extension.

If the package does not have subpackages, just call `TRIBITS_PACKAGE()`_
which calls this macro.

TRIBITS_PACKAGE_DEF()
+++++++++++++++++++++

Macro called in `<packageDir>/CMakeLists.txt`_ after subpackages are
processed in order to handle the libraries, tests, and examples of the
parent package.

Usage::

  TRIBITS_PACKAGE_DEF()

If the package does not have subpackages, just call `TRIBITS_PACKAGE()`_
which calls this macro.

This macro has several side effects:

* The variable ``PACKAGE_NAME`` is set in the local scope for usage by the
  package's ``CMakeLists.txt`` files.

* The intra-package dependency variables (i.e. list of include directories,
  list of libraries, etc.) are initialized to empty.

TRIBITS_PACKAGE_DEFINE_DEPENDENCIES()
+++++++++++++++++++++++++++++++++++++

Define the dependencies for a given `TriBITS SE Package`_ (i.e. a top-level
`TriBITS Package`_ or a `TriBITS Subpackage`_) in the package's
`<packageDir>/cmake/Dependencies.cmake`_ file.

Usage::

  TRIBITS_PACKAGE_DEFINE_DEPENDENCIES(
     [LIB_REQUIRED_PACKAGES <pkg1> <pkg2> ...]
     [LIB_OPTIONAL_PACKAGES <pkg1> <pkg2> ...]
     [TEST_REQUIRED_PACKAGES <pkg1> <pkg2> ...]
     [TEST_OPTIONAL_PACKAGES <pkg1> <pkg2> ...]
     [LIB_REQUIRED_TPLS <tpl1> <tpl2> ...]
     [LIB_OPTIONAL_TPLS <tpl1> <tpl2> ...]
     [TEST_REQUIRED_TPLS <tpl1> <tpl2> ...]
     [TEST_OPTIONAL_TPLS <tpl1> <tpl2> ...]
     [REGRESSION_EMAIL_LIST  <regression-email-address>
     [SUBPACKAGES_DIRS_CLASSIFICATIONS_OPTREQS
       <spkg1_name>  <spkg1_dir>  <spkg1_classifications>  <spkg1_optreq>
       <spkg2_name>  <spkg2_dir>  <spkg2_classifications>  <spkg2_optreq>
       ...
       ]
     )

Every argument in this macro is optional (that is, an SE package can have no
upstream dependencies).  The arguments that apply to all SE packages are:

  ``LIB_REQUIRED_PACKAGES``

    List of required upstream SE packages that must be enabled in order to
    build and use the libraries (or capabilities) in this SE package.
 
  ``LIB_OPTIONAL_PACKAGES``

    List of additional optional upstream SE packages that can be used in
    this SE package if enabled.  These upstream SE packages need not be
    enabled in order to enable this SE package but not enabling one or more
    of these optional upstream SE packages will result in diminished
    capabilities of this SE package.
 
  ``TEST_REQUIRED_PACKAGES``

    List of additional upstream SE packages that must be enabled in order to
    build and/or run the tests and/or examples in this SE package.  If any
    of these upstream SE packages are not enabled, then there will be no
    tests or examples defined or run for this SE package.
 
  ``TEST_OPTIONAL_PACKAGES``

    List of additional optional upstream SE packages that can be used by the
    tests in this SE package.  These upstream SE packages need not be
    enabled in order to run some basic tests or examples for this SE
    package.  Typically, extra tests that depend on optional test SE
    packages involve integration testing of some type.
 
  ``LIB_REQUIRED_TPLS``

    List of required upstream TPLs that must be enabled in order to build
    and use the libraries (or capabilities) in this SE package.
 
  ``LIB_OPTIONAL_TPLS``

    List of additional optional upstream TPLs that can be used in this SE
    package if enabled.  These upstream TPLs need not be enabled in order to
    use this SE package but not enabling one or more of these optional
    upstream TPLs will result in diminished capabilities of this SE package.
 
  ``TEST_REQUIRED_TPLS``

    List of additional upstream TPLs that must be enabled in order to build
    and/or run the tests and/or examples in this SE package.  If any of
    these upstream TPLs are not enabled, then there will be no tests or
    examples defined or run for this SE package.
 
  ``TEST_OPTIONAL_TPLS``

    List of additional optional upstream TPLs that can be used by the tests
    in this SE package.  These upstream TPLs need not be enabled in order to
    run basic tests for this SE package.  Typically, extra tests that depend
    on optional TPLs involve integration testing or some additional testing
    of some type.

Only upstream SE packages can be listed (as defined by the order the SE
packages are listed in `TRIBITS_REPOSITORY_DEFINE_PACKAGES()`_ in the
`<repoDir>/PackagesList.cmake`_ file).  Otherwise an error will occur and
processing will stop.  Misspelled SE package names are caught as well.

Only direct SE package dependencies need to be listed.  Indirect SE package
dependencies are automatically handled.  For example, if this SE package
directly depends on SE package ``PKG2`` which depends on SE package ``PKG1``
(but this SE package does not directly depend on anything in ``PKG1``) then
this SE package only needs to list a dependency on ``PKG2``, not ``PKG1``.
The dependency on ``PKG1`` will be taken care of automatically by the
TriBITS dependency management system.

However, currently, all TPL dependencies must be listed, even the indirect
ones.  This is a requirement that will be dropped in a future version of
TriBITS.

The SE packages listed in ``LIB_REQUIRED_PACKAGES`` are implicitly also
dependencies in ``TEST_REQUIRED_PACKAGES``.  Likewise
``LIB_OPTIONAL_PACKAGES`` are implicitly also dependencies in
``TEST_OPTIONAL_PACKAGES``.  Same goes for TPL dependencies.

The upstream dependencies within a single list do not need to be listed in
any order.  For example if ``PKG2`` depends on ``PKG1``, and this given SE
package depends on both, then one can list::

  LIB_REQUIRED_PACKAGES PKG2 PKG1

or::

  "LIB_REQUIRED_PACKAGES PKG1 PKG2

Likewise the order that dependent TPLs are listed is not significant.

If some upstream SE packages are allowed to be missing, this can be specified
by calling the macro `TRIBITS_ALLOW_MISSING_EXTERNAL_PACKAGES()`_.

A top-level `TriBITS Package`_ can also be broken down into `TriBITS
Subpackages`_.  In this case, the following argument must be passed in:

  .. _SUBPACKAGES_DIRS_CLASSIFICATIONS_OPTREQS:

  ``SUBPACKAGES_DIRS_CLASSIFICATIONS_OPTREQS``

    2D array with rows listing the subpackages where each row has the
    columns:

    * **SUBPACKAGE** (Column 0): The name of the subpackage ``<spkg_name>``.
      The full SE package name is ``${PARENT_PACKAGE_NAME}<spkg_name>``.
      The full SE package name is what is used in listing dependencies in
      other SE packages.
   
    * **DIRS** (Column 1): The subdirectory ``<spkg_dir>`` relative to the
      parent package's base directory.  All of the contents of the
      subpackage should be under this subdirectory.  This is assumed by the
      TriBITS testing support software when mapping modified files to SE
      packages that need to be tested (see `checkin-test.py`_).
   
    * **CLASSIFICATIONS** (Column 2): The `Test Test Category`_ `PT`_,
      `ST`_, `EX`_ and the maturity level ``EP``, ``RS``, ``PG``, ``PM``,
      ``GRS``, ``GPG``, ``GPM``, and ``UM``, separated by a coma ',' with no
      spaces in between (e.g. ``"PT,GPM"``).  These have exactly the same
      meaning as for full packages (see
      `TRIBITS_REPOSITORY_DEFINE_PACKAGES()`_).
   
    * **OPTREQ** (Column 3): Determines if the outer parent package has an
      ``OPTIONAL`` or ``REQUIRED`` dependence on this subpackage.

Other variables that this macro handles:

  ``REGRESSION_EMAIL_LIST``

    The email list that is used to send CDash error messages.  If this
    argument is missing, then the email list that CDash errors go to is
    determined by other means (see `CDash regression email addresses`_).

NOTE: All this macro really does is to just define the variables:

* ``LIB_REQUIRED_DEP_PACKAGES``
* ``LIB_OPTIONAL_DEP_PACKAGES``
* ``TEST_REQUIRED_DEP_PACKAGES``
* ``TEST_OPTIONAL_DEP_PACKAGES``
* ``LIB_REQUIRED_DEP_TPLS``
* ``LIB_OPTIONAL_DEP_TPLS``
* ``TEST_REQUIRED_DEP_TPLS``
* ``TEST_OPTIONAL_DEP_TPLS``
* ``REGRESSION_EMAIL_LIST``
* ``SUBPACKAGES_DIRS_CLASSIFICATIONS_OPTREQS``

which are then read by the TriBITS cmake code to build the SE package
dependency graph.  The advantage of using this macro instead of just
directly setting the variables is that an SE package only needs to list
dependencies that exist.  Otherwise, the ``Dependencies.cmake`` file will
need to set all of the above local variables, even those that are empty.
This is a error checking property of the TriBITS system to avoid misspelling
the names of these variables.

TRIBITS_PACKAGE_POSTPROCESS()
+++++++++++++++++++++++++++++
 
Macro called at the very end of a package's top-level
`<packageDir>/CMakeLists.txt`_ file that performs some critical
post-processing activities.

Usage::

  TRIBITS_PACKAGE_POSTPROCESS()

NOTE: It is unfortunate that this macro must be called in a packages's
top-level ``CMakeLists.txt`` file but limitations of the CMake language make
it necessary to do so.

TRIBITS_PROCESS_SUBPACKAGES()
+++++++++++++++++++++++++++++

Macro that processes the `TriBITS Subpackages`_ for a parent `TriBITS
package`_ for packages that are broken down into subpackages.  This is
called in the parent packages top-level `<packageDir>/CMakeLists.txt`_ file.

Usage::

  TRIBITS_PROCESS_SUBPACKAGES()

This macro must be called after `TRIBITS_PACKAGE_DECL()`_ but before
`TRIBITS_PACKAGE_DEF()`_.

TRIBITS_PROJECT()
+++++++++++++++++

Processes a `TriBITS Project`_'s files and configures its software which is
called from the project's top-level `<projectDir>/CMakeLists.txt`_ file.

Usage::

  TRIBITS_PROJECT()

This macro requires that the variable `PROJECT_NAME`_ be defined before
calling this macro.  All default values for project settings should be set
before calling this macro (see `TriBITS Global Project Settings`_).  Also,
the variable `${PROJECT_NAME}_TRIBITS_DIR`_ must be set as well.

This macro then adds all of the necessary paths to ``CMAKE_MODULE_PATH`` and
then performs all processing of the TriBITS project files (see `Full TriBITS
Project Configuration`_).

TRIBITS_PROJECT_DEFINE_EXTRA_REPOSITORIES()
+++++++++++++++++++++++++++++++++++++++++++

Declare a set of extra repositories for the `TriBITS Project`_ (i.e. in the
project's `<projectDir>/cmake/ExtraRepositoriesList.cmake`_ file).

Usage::

  TRIBITS_PROJECT_DEFINE_EXTRA_REPOSITORIES(
    <repo0_name> <repo0_dir> <repo0_type> <repo0_url> <repo0_packstat> <repo0_classif>
    <repo1_name> <repo1_dir> <repo1_type> <repo1_url> <rep10_packstat> <repo1_classif>
    ...
   )

This macro takes in a 2D array with 6 columns, where each row defines an
extra repository.  The 6 columns (ordered 0-5) are:

0. **REPO_NAME** (``<repoi_name>``): The name given to the repository
   ``REPOSITORY_NAME``.

1. **REPO_DIR** (``<repoi_dir>``): The relative directory for the repository
   under the project directory ``${PROJECT_SOURCE_DIR}`` (or
   ``<projectDir>``).  If this is set to empty quoted string ``""``, then
   the relative directory name is assumed to be same as the repository name
   ``<repoi_name>``.

2. **REPO_TYPE** (``<repoi_type>``): The version control (VC) type of the
   repo.  Value choices include ``GIT`` and ``SVN`` (i.e. Subversion).
   *WARNING:* Only VC repos of type ``GIT`` can fully participate in the
   TriBITS development tool workflows.  The other VC types are supported for
   basic cloning and updating using `TRIBITS_CTEST_DRIVER()`_ script.

3. **REPO_URL** (``<repoi_url>``): The URL of the VC repo.  This info is
   used to initially obtain the repo source code using the VC tool listed in
   ``<repoi_type>``.  If the repos don't need to be cloned for the needed
   use cases, then this can be the empty quoted string ``""``.

4. **REPO_PACKSTAT** (``<repoi_packstat>``): Determines if the VC repository
   contains any TriBITS packages or if it just provides directories and
   files.  If the VC repo contains TriBITS packages, then this field must be
   the empty quoted string ``""``, and this repository is considered to be a
   `TriBITS Repository`_ and must therefore contain the files described in
   `TriBITS Repository Core Files`_.  If the listed repository is **not** a
   TriBITS repository, and just provides directories and files, then this
   field must be set as ``NOPACKAGES``.

5. **REPO_CLASSIFICATION** (``<repoi_classif>``): Gives the `Repository Test
   Classification`_ also happens to be the CTest/CDash testing mode and the
   default dashboard track.  Valid values are ``Continuous``, ``Nightly``,
   and ``Experimental``.  See `Repository Test Classification`_ for a
   detailed description.

This command is used to put together one or more VC and/or TriBITS
repositories to construct a composite `TriBITS Project`_.  The option
`<Project>_EXTRAREPOS_FILE`_ is used to point to files that call this macro.
Repositories with ``<repoi_packstat>=NOPACKAGES`` are **not** TriBITS
Repositories and are technically not considered at all during the basic
configuration of the a TriBITS project.  They are only listed in this file
so that they can be used in the version control logic for tools that perform
version control with the repositories (such as cloning, updating, looking
for changed files, etc.).  For example, a non-TriBITS repo can be used to
grab a set of directories and files that fill in the definition of a package
in an upstream repository (see `How to insert a package into an upstream
repo`_).  Also, non-TriBITS repos can be used to provide extra test data for
a given package or a set of packages so that extra tests can be run.

It is also allowed for a repository to have ``<repoi_url>=""`` and
``<repoi_packstat>=""`` which means that the given repository directory
**is** a TriBITS Repository (and therefore provides TriBITS packages and
TPLs) but that there is no independent VC repo used to manage the software.

NOTE: These repositories must be listed in the order of package
dependencies.  That is, all of the packages listed in repository ``i`` must
have upstream TPL and SE package dependencies listed before this package in
this repository or in upstream repositories ``i-1``, ``i-2``, etc.

NOTE: This module just sets the local variable::

 ${PROJECT_NAME}_EXTRAREPOS_DIR_REPOTYPE_REPOURL_PACKSTAT_CATEGORY

in the current scope.  The advantages of using this macro instead of
directly setting this variable are that the macro:

* Asserts that the variable ``PROJECT_NAME`` is defined and set.

* Avoids misspelling the name of the variable
  ``${PROJECT_NAME}_EXTRAREPOS_DIR_REPOTYPE_REPOURL_PACKSTAT_CATEGORY``.  If
  one misspells the name of a macro, it is an immediate error in CMake.  A
  misspelled set variable is just ignored.

TRIBITS_REPOSITORY_DEFINE_PACKAGES()
++++++++++++++++++++++++++++++++++++

Define the set of packages for a given `TriBITS Repository`_.  This macro is
typically called from inside of a `<repoDir>/PackagesList.cmake`_ file for a
given TriBITS repo.

Usage::

   TRIBITS_REPOSITORY_DEFINE_PACKAGES(
      <pkg0>  <pkg0_dir>  <pkg0_classif>
      <pkg1>  <pkg1_dir>  <pkg1_classif>
      ...
      )

This macro sets up a 2D array of ``NumPackages`` by ``NumColumns`` listing
out the packages for a TriBITS repository.  Each row (with 3 column entries)
specifies a package which contains the columns (ordered 0-2):

0. **PACKAGE** (``<pkgi>``): The name of the TriBITS package.  This name
   must be unique across all other TriBITS packages in this or any other
   TriBITS repo that might be combined into a single TriBITS project
   meta-build (see `Globally unique TriBITS package names`_).  The name
   should be a valid identifier (e.g. matches the regex
   ``[a-zA-Z_][a-zA-Z0-9_]*``).  The package names tend to used mixed case
   (e.g. ```SomePackge`` not ``SOMEPACKGE``).

1. **DIR** (``<pkgi_dir>``): The relative directory for the package
   ``<packageDir>``.  This directory is relative to the TriBITS repository
   base directory ``<repoDir>``.  Under this directory will be a
   package-specific ``cmake/`` directory with the file
   `<packageDir>/cmake/Dependencies.cmake`_ and a base-level
   `<packageDir>/CMakeLists.txt`_ file.  The entire contents of the package
   including all of the source code and all of the tests should be contained
   under this directory.  The TriBITS testing infrastructure relies on the
   mapping of changed files to these base directories when deciding what
   packages are modified and need to be retested (along with downstream
   packages).  For details, see `checkin-test.py`_.

2. **CLASSIFICATION** (``<pkgi_classif>``): Gives the `SE Package Test
   Group`_ `PT`_, `ST`_, or `EX`_ and the maturity level ``EP``, ``RS``,
   ``PG``, ``PM``, ``GRS``, ``GPG``, ``GPM``, ``UM``.  These are separated
   by a coma with no space in between such as ``"RS,PT"`` for a "Research
   Stable", "Primary Tested" package.  No spaces are allowed so that CMake
   treats this a one field in the array.  The maturity level can be left off
   in which case it is assumed to be ``UM`` for "Unspecified Maturity".
   This classification for individual packages can be changed to ``EX`` for
   specific platforms by calling `TRIBITS_DISABLE_PACKAGE_ON_PLATFORMS()`_.

**IMPORTANT:** The packages must be listed in increasing order of package
dependencies.  That is `No circular dependencies of any kind are allowed`_
(see the *ADP (Acyclic Dependencies Principle)* in `Software Engineering
Packaging Principles`_).  Package ``i`` can only list dependencies (in
`<packageDir>/cmake/Dependencies.cmake`_) for packages listed before this
package in this list (or in upstream TriBITS repositories).  This avoids an
expensive package sorting algorithm and makes it easy to flag packages with
circular dependencies or misspelling of package names.

NOTE: This macro just sets the variable::

  ${REPOSITORY_NAME}_PACKAGES_AND_DIRS_AND_CLASSIFICATIONS

in the current scope.  The advantages of using this macro instead of
directly setting this variable are that the macro:

* Asserts that the variable ``REPOSITORY_NAME`` is defined and set

* Avoids having to hard-code the assumed repository name
  ``${REPOSITORY_NAME}``.  This provides more flexibility for how other
  TriBITS projects choose to name a given TriBITS repo (i.e. the name of
  repo subdirs).

* Avoid misspelling the name of the variable
  ``${REPOSITORY_NAME}_PACKAGES_AND_DIRS_AND_CLASSIFICATIONS``.  If one
  misspells the name of the macro, it is an immediate error in CMake.

TRIBITS_REPOSITORY_DEFINE_TPLS()
++++++++++++++++++++++++++++++++

Define the list of `TriBITS TPLs`_ for a given `TriBITS Repository`_ which
includes the TPL name, find module, and classification .  This macro is
typically called from inside of the repository's `<repoDir>/TPLsList.cmake`_
file.

Usage::

  TRIBITS_REPOSITORY_DEFINE_TPLS(
    <tpl0_name>   <tpl0_findmod>  <tpl0_classif>
    <tpl1_name>   <tpl1_findmod>  <tpl1_classif>
    ...
    )

This macro sets up a 2D array of ``NumTPLS`` by ``NumColumns`` listing out
the `TriBITS TPLs`_ for a `TriBITS Repository`_.  Each row (with 3 entries)
specifies a TPL which contains the columns (ordered 0-2):

0. **TPL** (``<tpli_name>``): The name of the TriBITS TPL ``<tplName>``.
   This name must be unique across all other TriBITS TPLs in this or any
   other TriBITS repo that might be combined into a single TriBITS project
   meta-build (see `Globally unique TriBITS TPL names`_).  However, a TPL
   can be redefined from an upstream repo (see below).  The name should be a
   valid identifier (e.g. matches the regex ``[a-zA-Z_][a-zA-Z0-9_]*``).
   TPL names typically use mixed case (e.g. ``SomeTpl`` and not
   ``SOMETPL``).

1. **FINDMOD** (``<tpli_findmod>``): The relative path for the find module,
   usually with the name ``FindTPL<tplName>.cmake``.  This path is relative
   to the repository base directory.  If just the base path for the find
   module is given, ending with ``"/"`` (e.g. ``"cmake/tpls/"``), then the
   find module will be assumed to be under that this directory with the
   standard name (e.g. ``cmake/tpls/FindTPL<tplName>.cmake``).  A standard
   way to write a ``FindTPL<tplName>.cmake`` module is to use the function
   `TRIBITS_TPL_DECLARE_LIBRARIES()`_.

2. **CLASSIFICATION** (``<pkgi_classif>``): Gives the `SE Package Test
   Group`_ `PT`_, `ST`_, or `EX`_ and the maturity level ``EP``, ``RS``,
   ``PG``, ``PM``, ``GRS``, ``GPG``, ``GPM``, ``UM``.  These are separated
   by a coma with no space in between such as ``"RS,PT"`` for a "Research
   Stable", "Primary Tested" package.  No spaces are allowed so that CMake
   treats this a one field in the array.  The maturity level can be left off
   in which case it is assumed to be ``UM`` for "Unspecified Maturity".

A TPL defined in a upstream repo can listed again in a downstream repo,
which allows redefining the find module that is used to specify the TPL.
This allows downstream repos to add additional requirements for a given TPL
(i.e. add more libraries, headers, etc.).  However, the downstream repo's
find module file must find the TPL components that are fully compatible with
the upstream's find module.

This macro just sets the variable::

  ${REPOSITORY_NAME}_TPLS_FINDMODS_CLASSIFICATIONS

in the current scope.  The advantages of using this macro instead of
directly setting this variable are that the macro:

* Asserts that the variable ``REPOSITORY_NAME`` is defined and set

* Avoids having to hard-code the assumed repository name
  ``${REPOSITORY_NAME}``.  This provides more flexibility for how other
  TriBITS projects choose to name a given TriBITS repo (i.e. the name of
  repo subdirs).

* Avoids misspelling the name of the variable
  ``${REPOSITORY_NAME}_TPLS_FINDMODS_CLASSIFICATIONS``.  If one misspells
  the name of a macro, it is an immediate error in CMake.

TRIBITS_SET_ST_FOR_DEV_MODE()
+++++++++++++++++++++++++++++

Function that allows packages to easily make a feature ``ST`` for
development builds and ``PT`` for release builds by default.

Usage::

  TRIBITS_SET_ST_FOR_DEV_MODE(<outputVar>)

This function is typically called in a package's top-level
`<packageDir>/CMakeLists.txt`_ file before defining other options for the
package.  The output variable ``${<outputVar>}`` is set to ``ON`` or ``OFF``
based on the configure state.  In development mode
(i.e. ``${PROJECT_NAME}_ENABLE_DEVELOPMENT_MODE==ON``), ``${<outputVar>}``
will be set to ``ON`` only if ``ST`` code is enabled
(i.e. ``${PROJECT_NAME}_ENABLE_SECONDARY_TESTED_CODE==ON``), otherwise it is
set to ``OFF``. In release mode
(i.e. ``${PROJECT_NAME}_ENABLE_DEVELOPMENT_MODE==OFF``), ``${<outputVar>}``
is always set to ``ON``.  This allows some parts of a TriBITS package to be
considered ``ST`` for development mode (thereby reducing testing time by not
enabling the dependent features/tests), while still having important
functionality available to users by default in a release of the package.

TRIBITS_SUBPACKAGE()
++++++++++++++++++++

Forward declare a `TriBITS Subpackage`_ called at the top of the
subpackage's `<packageDir>/<spkgDir>/CMakeLists.txt`_ file.

Usage::

  TRIBITS_SUBPACKAGE(<spkgName>)

Once called, the following local variables are in scope:

  ``PARENT_PACKAGE_NAME``

    The name of the parent package.

  ``SUBPACKAGE_NAME``

    The local name of the subpackage (does not contain
    the parent package name).

  ``SUBPACKAGE_FULLNAME``

    The full project-level name of the subpackage (which includes the parent
    package name at the beginning,
    ``${PARENT_PACKAGE_NAME}${SUBPACKAGE_NAME}``).

  ``PACKAGE_NAME``

    Inside the subpackage, the same as ``SUBPACKAGE_FULLNAME``.

TRIBITS_SUBPACKAGE_POSTPROCESS()
++++++++++++++++++++++++++++++++

Macro that performs standard post-processing after defining a `TriBITS
Subpackage`_ which is called at the bottom of a subpackage's
`<packageDir>/<spkgDir>/CMakeLists.txt`_ file.

Usage::

  TRIBITS_SUBPACKAGE_POSTPROCESS()

NOTE: It is unfortunate that a Subpackages's CMakeLists.txt file must call
this macro but limitations of the CMake language make it necessary to do so.

TRIBITS_TPL_DECLARE_LIBRARIES()
+++++++++++++++++++++++++++++++

Function that sets up cache variables for users to specify where to find a
`TriBITS TPL`_'s headers and libraries.  This function is typically called
inside of a ``FindTPL<tplName>.cmake`` file (see `${TPL_NAME}_FINDMOD`_).

Usage::

  TRIBITS_TPL_DECLARE_LIBRARIES(
    <tplName>
    [REQUIRED_HEADERS <header1> <header2> ...]
    [MUST_FIND_ALL_HEADERS]
    [REQUIRED_LIBS_NAMES <libname1> <libname2> ...]
    [MUST_FIND_ALL_LIBS]
    [NO_PRINT_ENABLE_SUCCESS_FAIL]
    )

This function can be called to specify/require header files and include
directories and/or a list of libraries.

The input arguments to this function are:

  ``<tplName>``

    Name of the TPL that is listed in a `<repoDir>/TPLsList.cmake`_ file.
    Below, this is referred to as the local CMake variable ``TPL_NAME``.

  ``REQUIRED_HEADERS``

    List of header files that are searched in order to find the TPL's
    include directories files using ``FIND_PATH()``.

  ``MUST_FIND_ALL_HEADERS``

    If set, then all of the header files listed in ``REQUIRED_HEADERS`` must
    be found in order for ``TPL_${TPL_NAME}_INCLUDE_DIRS`` to be defined.

  ``REQUIRED_LIBS_NAMES``

    List of libraries that are searched for when looking for the TPL's
    libraries using ``FIND_LIBRARY()``.

  ``MUST_FIND_ALL_LIBS``

    If set, then all of the library files listed in ``REQUIRED_LIBS_NAMES``
    must be found or the TPL is considered not found!

  ``NO_PRINT_ENABLE_SUCCESS_FAIL``

     If set, then the final success/fail will not be printed

This function implements the TPL find behavior described in `Enabling
support for an optional Third-Party Library (TPL)`_.

The following (cache) variables, if set, will be used by that this function:

  ``${TPL_NAME}_INCLUDE_DIRS`` (type ``PATH``)

    List of paths to search first for header files defined in
    ``REQUIRED_HEADERS``.

  ``${TPL_NAME}_INCLUDE_NAMES`` (type ``STRING``)

    List of include file names to be looked for instead of what is specified
    in ``REQUIRED_HEADERS``.

  ``${TPL_NAME}_LIBRARY_DIRS`` (type ``PATH``)

    The list of directories to search first for libraries defined in
    ``REQUIRED_LIBS_NAMES``.

  ``${TPL_NAME}_LIBRARY_NAMES`` (type ``STRING``)

    List of library names to be looked for instead of what is specified in
    ``REQUIRED_LIBS_NAMES``.

This function sets global variables to return state so it can be called from
anywhere in the call stack.  The following cache variables are defined that
are intended for the user to set and/or use:

  ``TPL_${TPL_NAME}_INCLUDE_DIRS`` (type ``PATH``)

    A list of common-separated full directory paths that contain the TPL's
    header files.  If this variable is set before calling this function,
    then no headers are searched for and this variable will be assumed to
    have the correct list of header paths.

  ``TPL_${TPL_NAME}_LIBRARIES`` (type ``FILEPATH``)

    A list of commons-separated full library names (i.e. output from
    ``FIND_LIBRARY()``) for all of the libraries found for the TPL.  If this
    variable is set before calling this function, then no libraries are
    searched for and this variable will be assumed to have the correct list
    of libraries to link to.

TRIBITS_WRITE_FLEXIBLE_PACKAGE_CLIENT_EXPORT_FILES()
++++++++++++++++++++++++++++++++++++++++++++++++++++

Utility function for writing ``${PACKAGE_NAME}Config.cmake`` and/or the
``Makefile.export.${PACKAGE_NAME}`` files for package ``${PACKAGE_NAME}``
with some greater flexibility than what is provided by the function
``TRIBITS_WRITE_PACKAGE_CLIENT_EXPORT_FILES()``.

Usage::

  TRIBITS_WRITE_FLEXIBLE_PACKAGE_CLIENT_EXPORT_FILES(
    PACKAGE_NAME <pakageName>
    [EXPORT_FILE_VAR_PREFIX <exportFileVarPrefix>]
    [WRITE_CMAKE_CONFIG_FILE <cmakeConfigFileFullPath>]
    [WRITE_EXPORT_MAKLEFILE <exportMakefileFileFullPath>]
    [WRITE_INSTALL_CMAKE_CONFIG_FILE]
    [WRITE_INSTALL_EXPORT_MAKLEFILE]
    )

The arguments are:

  ``PACKAGE_NAME <pakageName>``
 
    Gives the name of the TriBITS package for which the export files should
    be created.
 
  ``EXPORT_FILE_VAR_PREFIX <exportFileVarPrefix>``
 
    If specified, then all of the variables in the generated export files
    will be prefixed with ``<exportFileVarPrefix>_`` instead of
    ``<pakageName>_``.
 
  ``WRITE_CMAKE_CONFIG_FILE <cmakeConfigFileFullPath>``
 
    If specified, then the package's (``<packageName>``) cmake configure
    export file for use by external CMake client projects will be created as
    the file ``<cmakeConfigFileFullPath>``.  NOTE: the argument should be
    the full path!
 
  ``WRITE_EXPORT_MAKLEFILE <exportMakefileFileFullPath>``
 
    If specified, then the package's (``<packageName>``) export makefile for
    use by external Makefile client projects will be created in the file
    <exportMakefileFileFullPath>.  NOTE: the argument should be the full
    path!
 
  ``WRITE_INSTALL_CMAKE_CONFIG_FILE``
 
    If specified, then the package's (``<packageName>``) install cmake
    configured export file will be installed in to the install tree as well.
    The name and location of this file is hard-coded.
 
  ``WRITE_INSTALL_EXPORT_MAKLEFILE``
 
    If specified, then the package's (``<packageName>``) install export
    makefile to be installed into the install tree as well.  The name and
    location of this file is hard-coded.

NOTE: The arguments to this function may look strange but the motivation is
to support very specialized use cases such as when a TriBITS package needs
to generate an export makefile for a given package but the name of the
export makefile must be different and use different variable name prefixes.
The particular use case is when wrapping an external autotools project that
depends on Trilinos and needs to read in the ``Makefile.export.Trilinos``
file but this file needs to be generated for a subset of enabled packages on
the fly during a one-pass configure.

NOTE: This function does *not* contain the ``INSTALL()`` commands because
CMake will not allow those to even be present in scripting mode that is used
for unit testing this function.  Instead, the files to be installed are only
generated in the build tree and the install targets are added else where.

