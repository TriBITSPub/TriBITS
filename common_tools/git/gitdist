#!/usr/bin/env python

usageHelp = r"""gitdist [gitdist arguments] [git arguments]

Run git recursively over extra repos and some extra tools for multi-repository
git projects.

Instead of typing:

  $ git [git arguments]

type:

  $ gitdist [gitdist options] [git arguments]

This will distribute git commands across all git repos listed, including the
base git repo.  The options in [gitdist options] are prefixed with '--dist-'
and are are pulled out off before passing the remaining arguments in [git
arguments] to all the git repos.  See --help to see the [gitdist options].

For example, consider the following git repos with other git repos cloned
under it:

  SomeBaseRepo/
    .git/
    ExtraRepo1/
      .git/
    ExtraRep2/
      .git/

The gitdist command is run in the base git repo 'SomeBaseRepo' and the git
commands are run on it as well as the git repos 'ExtraRepo1' and 'ExtraRepo2'.

The set of repos processed is determined by the argument --dist-extra-repos or
the files .gitdist or .gitdist.default.  If --dist-extra-repos="", then the
list of extra repos will be read from the file '.gitdist' in the current
working directory.  If the file '.gitdist' does not exist, then the list of
extra repos will be read from the file '.gitdist.default in' the current
working directory.  The format of this files '.gitdist' and '.gitdist.default'
is to have one repo directory/name per line as in:

  ExtraRepo1
  ExtraRepo2
  ...

where each repo is the relative path to the repo under the base git repo
(e.g. under 'SomeBaseRepo/').  The file .gitdist.default is meant to be
committed to the base git repo so that gitdist is ready to use right away.

If an extra repository does not exist, then it will be ignored.  Therefore, be
careful to manually verify that the script recognizes the repositories that
you list.  The best way to do that is to type 'gitdist status'.

This script has no dependencies other than standard python 2.4 packages so it
can be copied to anywhere and used.

TIPS:

 - To process only changed repos w.r.t. their tracking branch, run
   'gitdist --dist-mod-only [git arguments]'.  For example, to see
   the status of only changed repos use 'gitdist --dist-mod-only status'.

 - Use 'gitdist --no-pager <command> ...' to get the full output from
   all extra repos in one contiguous stream which can then be piped
   to 'less' or to a file to be read with emacs or vi (may also want
   to use --dist-no-color as well).

 - 'gitdist --help' will run gitdist help, not git help.  If you want git
   help, run raw 'git --help'.

 - By default, gitdist will use 'git' in the environment.  If it can't find
   'git' in the environment, it will require that the user specify the git
   command to run with --dist-use-git=<the command>.

 - To exclude processing either the base git repo and/or other git repos
   listed in .gitdist, pass in --dist-not-base-repo and/or
   --dist-not-extra-repos=RepoX,RepoZ,...  This provides complete control over
   what git repos the given git command is run.

REPO VERSION FILES:

This script also supports the options --dist-version-file=<versionFile> and
--dist-version-file2=<versionFile2> which are used to provide different SHA1
versions for each repo.  Each of these version files is expected to represent
a compatible set of versions of the repos.

The format of these repo version files is a follows:

-----------------------------------------------------
*** Base Git Repo: SomeBaseRepo
e102e27 [Mon Sep 23 11:34:59 2013 -0400] <author1@someurl.com>
First summary message
*** Git Repo: ExtraRepo1
b894b9c [Fri Aug 30 09:55:07 2013 -0400] <author2@someurl.com>
Second summary message
*** Git Repo: ExtraRepo2
97cf1ac [Thu Dec 1 23:34:06 2011 -0500] <author3@someurl.com>
Third summary message
...
-----------------------------------------------------

Each repository entry can have a summary message or not (i.e. use two or three
lines per repo in the file).  A compatible repo version file can be generated
with this script using, for example, using:

  $ gitdist --dist-no-color log -1 --pretty=format:"%h [%ad] <%ae>%n%s" \
    | grep -v "^$" &> RepoVersion.txt

using three lines per repo, or just:

  $ gitdist --dist-no-color log -1 --pretty=format:"%h [%ad] <%ae>" \
    | grep -v "^$" &> RepoVersion.txt

using two lines per repo in the output file.

This allows checking out consistent versions of the repos, diffing two
consistent versions of the repos, etc.

To checkout an older set of consistent versions of the set of repos, use:

  $ gitdist fetch origin
  $ gitdist --dist-version-file=RepoVersion.SomeDate.txt checkout _VERSION_

The '_VERSION_' string will be replaced with the SHA1 for each of the repos.

To tag and branch the set of repos using a consistent set of versions, use:

  $ gitdist --dist-version-file=RepoVersion.SomeDate.txt \
    tag -a some_tag _VERSION_

To diff two sets of versions of the repos, for example, use:

  $ gitdist --dist-version-file=RepoVersion.NewerDate.txt \
     --dist-version-file2=RepoVersion.OlderDate.txt \
     diff _VERSION_ ^_VERSION2_

Here, _VERSION_ is replaced by the SHA1s listed in RepoVersion.NewerDate.txt
and _VERSION2_ is replaced by the SHA1s listed in RepoVersion.OlderDate.txt.

One can construct any git commit taking one or two different repo version
arguments (SHA1s).

Note that the set of repos listed in the RepoVersion.txt file must be a
super-set of those processed by this script or an error will occur and the
script will stop.

Note that this Python script only depends on the Python 2.4+ standard modules
'sys', 'os', 'subprocess', and 're'. Also, it requires some compatible version
of 'git' at the very minimum as well of course.

COMPARISONS TO GIT SUBMODULE:

The purpose and functioning of gitdist has a lot in common with the build-in
git submodule command.  While git submodule is well suited for pulling in
externally developed git repos, git submodules are not well suited for
managing the co-development of multiple git repos.  A more detailed discussion
of different approaches to managing the development and integration of
multiple git repos, see the TriBITS Developers Guide.
"""

import sys
import os
import subprocess
import re

from optparse import OptionParser


#
# Helper functions
#


# Get output from command
def getCmndOutput(cmnd, rtnCode=False):
  child = subprocess.Popen(cmnd, shell=True, stdout=subprocess.PIPE,
    stderr = subprocess.STDOUT)
  output = child.stdout.read()
  child.wait()
  if rtnCode:
    return (output, child.returncode)
  return output


# Run a command and syncronize the output
def runCmnd(options, cmnd):
  if options.debug:
    print "*** Running command:", cmnd
  if options.noOpt:
    print cmnd
  else:
    child = subprocess.Popen(cmnd, stdout=subprocess.PIPE).stdout
    output = child.read()
    sys.stdout.flush()
    print output
    sys.stdout.flush()


# Determine if a command exists:
def commandExists(cmnd):
  whichCmnd = getCmndOutput("which "+cmnd).strip()
  #print "whichCmnd =", whichCmnd
  if os.path.exists(whichCmnd):
    return True
  return False


# Get the terminal colors
txtbld=getCmndOutput(r"tput bold")       # Bold
txtblu=getCmndOutput(r"tput setaf 4")    # Blue
txtred=getCmndOutput(r"tput setaf 1")    # Red
txtrst=getCmndOutput(r"tput sgr0")       # Text reset


# Add color to the repo dirs printed out
def addColorToRepoDir(useColor, strIn):
  if useColor:
    return txtbld+txtblu+strIn+txtrst
  return strIn


# Add color to the error messages printed out
def addColorToErrorMsg(useColor, strIn):
  if useColor:
    return txtred+strIn+txtrst
  return strIn


# Get the commandline options
def getCommandlineOps():

  #
  # A) Define the native gitdist command-line arguments
  #

  clp = OptionParser(usage=usageHelp)

  helpArgName = "--help"
  withGitArgName = "--dist-use-git"
  extraRepoArgName = "--dist-extra-repos"
  notExtraRepoArgName = "--dist-not-extra-repos"
  notBaseRepoArgName = "--dist-not-base-repo"
  versionFileName = "--dist-version-file"
  versionFile2Name = "--dist-version-file2"
  noColorArgName = "--dist-no-color"
  debugArgName = "--dist-debug"
  noOptName = "--dist-no-opt"
  modifiedOnly = "--dist-mod-only"

  nativeArgNames = [ helpArgName, withGitArgName, \
    extraRepoArgName, notExtraRepoArgName, notBaseRepoArgName, \
    versionFileName, versionFile2Name, noColorArgName, debugArgName, noOptName, \
    modifiedOnly ]

  # Find a default git to use

  # Select a version of git (see above help documentation)

  defaultGit = "git" # Try system git
  if not commandExists(defaultGit):
    defaultGit = "" # Give up and make the user specify

  clp.add_option(
    withGitArgName, dest="useGit", type="string",
    default=defaultGit,
    help="The (path) to the git executable to use for each git repo command (default='"+defaultGit+"')"
    )

  clp.add_option(
    extraRepoArgName, dest="extraRepos", type="string",
    default="",
    help="Comma-separated list of extra repos to forward git commands to."
    +"  If the list is empty, it will look for a file called .gitdist to"
    +" get the list of extra repos separated by newlines."
    )

  clp.add_option(
    notExtraRepoArgName, dest="notExtraRepos", type="string",
    default="",
    help="Comma separated list of extra repos to *not* forward git commands to."
    +"  This removes any repos from being processed that would otherwise be."
    )

  clp.add_option(
    notBaseRepoArgName, dest="processBaseRepo", action="store_false",
    help="If set, don't pass the git command on to the base git repo.",
    default=True )

  clp.add_option(
    versionFileName, dest="versionFile", type="string",
    default="",
    help="Path to a file contains a list of extra repo directories and git versions (replaces _VERSION_)."
    )

  clp.add_option(
    versionFile2Name, dest="versionFile2", type="string",
    default="",
    help="Path to a second file contains a list of extra repo directories and git versions (replaces _VERSION2_)."
    )

  clp.add_option(
    noColorArgName, dest="useColor", action="store_false",
    help="If set, don't use color in the output for gitdist (better for output to a file).",
    default=True )

  clp.add_option(
    debugArgName, dest="debug", action="store_true",
    help="If set, then debugging info is printed.",
    default=False )

  clp.add_option(
    noOptName, dest="noOpt", action="store_true",
    help="If set, then no git commands will be run but instead will just be printed.",
    default=False )

  clp.add_option(
    modifiedOnly, dest="modifiedOnly", action="store_true",
    help="If set, then the listed git command will be only be run and output for the" \
      " repo will only be produced if the command 'git diff --name-only ^<tracking-branch>'"
      " returns non-empty output where <tracking-branch> is returned" \
      " from 'rev-parse --abbrev-ref --symbolic-full-name @{u}'.  In order words," \
      " if a git repo is unchanged w.r.t. its tracking branch, then the git command is" \
      " skipped for that repo.  If a repo does not have a tracking branch, then the repo will" \
      " be skipped as well.  Therefore, be careful to first run with dist-local-stat to see the" \
      " status of each local repo to know which repos don't have tracking branches.",
    default=False )

  #
  # B) Pull the native commandline arguments out of the commandline
  #

  argv = sys.argv[1:]
  nativeArgs = []
  otherArgs = []

  for arg in argv:
    #print "\narg = '"+arg+"'"
    matchedNativeArg = False
    for nativeArgName in nativeArgNames:
      #print "\nnativeArgName ='"+nativeArgName+"'"
      currentArgName = arg[0:len(nativeArgName)]
      #print "currentArgName = '"+currentArgName+"'"
      if currentArgName == nativeArgName:
        #print "\nMatches native arg!"
        nativeArgs.append(arg)
        matchedNativeArg = True
        break
    if not matchedNativeArg:
      #print "\nDoes *not* match native arg!"
      otherArgs.append(arg)
    #print "\nnativeArgs =", nativeArgs
    #print "otherArgs =", otherArgs

  #print "\nnativeArgs =", nativeArgs
  #print "otherArgs =", otherArgs

  (options, args) = clp.parse_args(nativeArgs)

  # Check for valid usage

  if len(otherArgs) == 0:
    print addColorToErrorMsg(options.useColor,
      "Must specify git command. See 'git --help' for options.")
    sys.exit(1)

  if not options.useGit:
    print addColorToErrorMsg(options.useColor,
      "Can't find git, please set --dist-use-git")
    sys.exit(2)

  # Get the list of extra repos

  if options.extraRepos:
    extraReposFullList = options.extraRepos.split(",")
  else:
    if os.path.exists(".gitdist"):
      gitdistfile = ".gitdist"
    elif os.path.exists(".gitdist.default"):
      gitdistfile = ".gitdist.default"
    else:
      gitdistfile = None
    if gitdistfile:
      extraReposFullList = open(gitdistfile, 'r').read().split()
    else:
      extraReposFullList = []

  # Get list of not extra repos

  if options.notExtraRepos:
    notExtraReposFullList = options.notExtraRepos.split(",")
  else:
    notExtraReposFullList = []

  return (options, otherArgs, extraReposFullList, notExtraReposFullList)


# Requote commandline arguments into an array
def requoteCmndLineArgsIntoArray(inArgs):
  argsArray = []
  for arg in inArgs:
    splitArg = arg.split("=")
    newArg = None
    if len(splitArg) == 1:
      newArg = arg
    else:
      newArg = splitArg[0]+"="+'='.join(splitArg[1:])
    #print "\nnewArg =", newArg
    argsArray.append(newArg)
  return argsArray


# Get a data-structure for a set of repos from a string
def getRepoVersionDictFromRepoVersionFileString(repoVersionFileStr):
  repoVersionFileStrList = repoVersionFileStr.split("\n")
  repoVersionDict = {}
  i = 0
  while i < len(repoVersionFileStrList):
    #print "i = ", i
    repoDirLine = repoVersionFileStrList[i]
    #print "repoDirLine = '"+repoDirLine+"'"
    if repoDirLine[0:3] == "***":
      repoDir = repoDirLine.split(":")[1].strip()
      #print "repoDir = '"+repoDir+"'"
      repoVersionLine = repoVersionFileStrList[i+1]
      #print "repoVersionLine = '"+repoVersionLine+"'"
      repoSha1 = repoVersionLine.split(" ")[0].strip()
      #print "repoSha1 = '"+repoSha1+"'"
      repoVersionDict.update({repoDir : repoSha1})
    else:
      break
    if repoVersionFileStrList[i+2][0:3] == "***":
      # Has no summary line
      i = i + 2
    else:
      # Has a summary line
      i = i + 3
  return repoVersionDict


# Get a data-structure for a set of repos from a file
def getRepoVersionDictFromRepoVersionFile(repoVersionFileName):
  if repoVersionFileName:
    repoVersionFileStr = open(repoVersionFileName, 'r').read()
    return getRepoVersionDictFromRepoVersionFileString(repoVersionFileStr)
  else:
    None


def assertAndGetRepoVersionFromDict(repoDirName, repoVersionDict):
  if repoVersionDict:
    repoSha1 = repoVersionDict.get(repoDirName, "")
    if not repoSha1:
      print addColorToErrorMsg(options.useColor,
        "Extra repo '"+repoDirName+"' is not in the list of extra repos "+\
        str(repoVersionDict.keys()[1:])+" read in from version file.")
      sys.exit(3)
    return repoSha1
  else:
    return ""


def replaceRepoVersionInCmndLineArg(cmndLineArg, verToken, repoDirName, repoSha1):
  if repoSha1:
    newCmndLineArg = re.sub(verToken, repoSha1, cmndLineArg)
    return newCmndLineArg
  return cmndLineArg


def replaceRepoVersionInCmndLineArgs(cmndLineArgsArray, repoDirName, \
  repoVersionDict, repoVersionDict2 \
  ):
  #print "repoDirName =", repoDirName
  repoSha1 = assertAndGetRepoVersionFromDict(repoDirName, repoVersionDict)
  repoSha1_2 = assertAndGetRepoVersionFromDict(repoDirName, repoVersionDict2)
  #print "repoSha1 =", repoSha1
  #print "repoSha1_2 =", repoSha1_2
  cmndLineArgsArrayRepo = []
  for cmndLineArg in cmndLineArgsArray:
    #print "cmndLineArg =", cmndLineArg
    newCmndLineArg = replaceRepoVersionInCmndLineArg(cmndLineArg, \
      "_VERSION_", repoDirName, repoSha1)
    #print "newCmndLineArg =", newCmndLineArg
    newCmndLineArg = replaceRepoVersionInCmndLineArg(newCmndLineArg, \
      "_VERSION2_", repoDirName, repoSha1_2)
    #print "newCmndLineArg =", newCmndLineArg
    cmndLineArgsArrayRepo.append(newCmndLineArg)
  return cmndLineArgsArrayRepo


# Generate the command line arguments
def runRepoCmnd(options, cmndLineArgsArray, repoDirName, baseDir, \
  repoVersionDict, repoVersionDict2 \
  ):
  cmndLineArgsArryRepo = replaceRepoVersionInCmndLineArgs(cmndLineArgsArray, \
    repoDirName, repoVersionDict, repoVersionDict2)
  egCmndArray = [ options.useGit ] + cmndLineArgsArryRepo
  runCmnd(options, egCmndArray)


# Determine if the extra repo should be processed or not
def repoExistsAndNotExcluded(options, extraRepo, notExtraReposList):
  if not os.path.isdir(extraRepo): return False
  if extraRepo in notExtraReposList: return False
  return True


# Get the tracking branch for a repo
def getTrackingBranch(options):
  (trackingBranch, rtnCode) = getCmndOutput(
    options.useGit + " rev-parse --abbrev-ref --symbolic-full-name @{u}",
    rtnCode=True )
  if rtnCode == 0:
    return trackingBranch.strip()
  return ""


# Determine if the repo has any changes w.r.t. tracking branch?
def repoHasLocalChanges(options, trackingBranch):
  statusOutput = getCmndOutput(
    options.useGit + " status --porcelain"
    ).strip()
  if statusOutput:
    return True
  if not trackingBranch:
    return False
  gitDiffOutput = getCmndOutput(
    options.useGit + " diff --name-only ^"+trackingBranch
    ).strip()
  if gitDiffOutput:
    return True
  return False


#
# Run the script
#

if __name__ == '__main__':

  (options, otherArgs, extraReposFullList, notExtraReposList) = getCommandlineOps()

  # Get the repo version files
  repoVersionDict = getRepoVersionDictFromRepoVersionFile(options.versionFile)
  repoVersionDict2 = getRepoVersionDictFromRepoVersionFile(options.versionFile2)

  # Reform the commandline arguments correctly
  #print "otherArgs =", otherArgs
  cmndLineArgsArray = requoteCmndLineArgsIntoArray(otherArgs)

  # Get the reference base directory
  baseDir = os.getcwd()

  if options.debug:
    print "*** Using git:", options.useGit

  # Get the name of the base repo
  baseDirArray = baseDir.split("/")
  baseRepoName = baseDirArray[-1]

  # See if we should process the base repo or not
  processBaseRepo = True
  if not options.processBaseRepo:
    processBaseRepo = False
  else:
    # See if we should process based on --dist-mod-only
    if options.modifiedOnly:
      trackingBranch = getTrackingBranch(options)
      if not repoHasLocalChanges(options, trackingBranch):
        processBaseRepo = False

  # Process the base git repo
  if processBaseRepo:
    print ""
    print "*** Base Git Repo: "+addColorToRepoDir(options.useColor, baseRepoName)
    if options.debug:
      print "*** Tracking branch for git repo '"+baseRepoName+"' = '"+trackingBranch+"'"
    sys.stdout.flush()
    runRepoCmnd(options, cmndLineArgsArray, baseRepoName, baseDir,
      repoVersionDict, repoVersionDict2)

  for extraRepo in extraReposFullList:

    processThisExtraRepo = True

    if not repoExistsAndNotExcluded(options, extraRepo, notExtraReposList):
      processThisExtraRepo = False

    if processThisExtraRepo:

      # Move into the extra repo
      if options.debug:
        print "\n*** Changing to directory "+extraRepo,
      os.chdir(extraRepo)

      # See if we should process based on --dist-mod-only
      if options.modifiedOnly:
        trackingBranch = getTrackingBranch(options)
        if not repoHasLocalChanges(options, trackingBranch):
          processThisExtraRepo = False

    if processThisExtraRepo:

      print ""
      print "*** Git Repo: "+addColorToRepoDir(options.useColor, extraRepo)
      sys.stdout.flush()
      if options.debug:
        print "*** Tracking branch for git repo '"+extraRepo+"' = '"+trackingBranch+"'"
      runRepoCmnd(options, cmndLineArgsArray, extraRepo, baseDir, \
        repoVersionDict, repoVersionDict2)
      if options.debug:
        print "*** Changing to directory "+baseDir

    os.chdir(baseDir)

  print ""
  sys.stdout.flush()

